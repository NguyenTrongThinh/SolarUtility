; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\queue.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\queue.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I.\Driver -I.\Application -I.\System\FreeRTOS\include -I.\System\FreeRTOS\portable\MemMang -I.\System\FreeRTOS\portable\RVDS\ARM_CM3 -I.\System\Libraries\CMSIS\CM3\CoreSupport -I.\System\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I.\System\Libraries\STM32F10x_StdPeriph_Driver\inc -ID:\ARM\SolarUtility\RTE -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=516 -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\objects\queue.crf System\FreeRTOS\queue.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  xQueueGenericReset PROC
;;;259    
;;;260    BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;261    {
000002  460d              MOV      r5,r1
;;;262    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000004  4604              MOV      r4,r0
;;;263    
;;;264    	configASSERT( pxQueue );
;;;265    
;;;266    	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;267    	{
;;;268    		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
00000a  e9d4120f          LDRD     r1,r2,[r4,#0x3c]
00000e  6820              LDR      r0,[r4,#0]
000010  fb010002          MLA      r0,r1,r2,r0
;;;269    		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000014  6060              STR      r0,[r4,#4]
000016  2000              MOVS     r0,#0
000018  63a0              STR      r0,[r4,#0x38]
;;;270    		pxQueue->pcWriteTo = pxQueue->pcHead;
00001a  6820              LDR      r0,[r4,#0]
00001c  1e49              SUBS     r1,r1,#1
;;;271    		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
00001e  60a0              STR      r0,[r4,#8]
000020  fb010002          MLA      r0,r1,r2,r0
;;;272    		pxQueue->xRxLock = queueUNLOCKED;
000024  60e0              STR      r0,[r4,#0xc]
000026  f04f30ff          MOV      r0,#0xffffffff
00002a  6460              STR      r0,[r4,#0x44]
;;;273    		pxQueue->xTxLock = queueUNLOCKED;
00002c  64a0              STR      r0,[r4,#0x48]
;;;274    
;;;275    		if( xNewQueue == pdFALSE )
00002e  b15d              CBZ      r5,|L1.72|
;;;276    		{
;;;277    			/* If there are tasks blocked waiting to read from the queue, then
;;;278    			the tasks will remain blocked as after this function exits the queue
;;;279    			will still be empty.  If there are tasks blocked waiting to write to
;;;280    			the queue, then one should be unblocked as after this function exits
;;;281    			it will be possible to write to it. */
;;;282    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;283    			{
;;;284    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
;;;285    				{
;;;286    					queueYIELD_IF_USING_PREEMPTION();
;;;287    				}
;;;288    				else
;;;289    				{
;;;290    					mtCOVERAGE_TEST_MARKER();
;;;291    				}
;;;292    			}
;;;293    			else
;;;294    			{
;;;295    				mtCOVERAGE_TEST_MARKER();
;;;296    			}
;;;297    		}
;;;298    		else
;;;299    		{
;;;300    			/* Ensure the event queues start in the correct state. */
;;;301    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
000030  f1040010          ADD      r0,r4,#0x10
000034  f7fffffe          BL       vListInitialise
;;;302    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
000038  f1040024          ADD      r0,r4,#0x24
00003c  f7fffffe          BL       vListInitialise
                  |L1.64|
;;;303    		}
;;;304    	}
;;;305    	taskEXIT_CRITICAL();
000040  f7fffffe          BL       vPortExitCritical
;;;306    
;;;307    	/* A value is returned for calling semantic consistency with previous
;;;308    	versions. */
;;;309    	return pdPASS;
000044  2001              MOVS     r0,#1
;;;310    }
000046  bd70              POP      {r4-r6,pc}
                  |L1.72|
000048  6920              LDR      r0,[r4,#0x10]         ;282
00004a  2800              CMP      r0,#0                 ;282
00004c  d0f8              BEQ      |L1.64|
00004e  f1040010          ADD      r0,r4,#0x10           ;284
000052  f7fffffe          BL       xTaskRemoveFromEventList
000056  2801              CMP      r0,#1                 ;284
000058  bf08              IT       EQ                    ;286
00005a  f7fffffe          BLEQ     vPortYield
00005e  e7ef              B        |L1.64|
;;;311    /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericCreate PROC
;;;312    
;;;313    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
000060  b570              PUSH     {r4-r6,lr}
;;;314    {
000062  000d              MOVS     r5,r1
000064  4606              MOV      r6,r0
;;;315    Queue_t *pxNewQueue;
;;;316    size_t xQueueSizeInBytes;
;;;317    QueueHandle_t xReturn = NULL;
000066  f04f0400          MOV      r4,#0
;;;318    int8_t *pcAllocatedBuffer;
;;;319    
;;;320    	/* Remove compiler warnings about unused parameters should
;;;321    	configUSE_TRACE_FACILITY not be set to 1. */
;;;322    	( void ) ucQueueType;
;;;323    
;;;324    	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
;;;325    
;;;326    	if( uxItemSize == ( UBaseType_t ) 0 )
;;;327    	{
;;;328    		/* There is not going to be a queue storage area. */
;;;329    		xQueueSizeInBytes = ( size_t ) 0;
00006a  bf0e              ITEE     EQ
00006c  2000              MOVEQ    r0,#0
;;;330    	}
;;;331    	else
;;;332    	{
;;;333    		/* The queue is one byte longer than asked for to make wrap checking
;;;334    		easier/faster. */
;;;335    		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00006e  fb06f005          MULNE    r0,r6,r5
000072  1c40              ADDNE    r0,r0,#1
000074  304c              ADDS     r0,r0,#0x4c
;;;336    	}
;;;337    
;;;338    	/* Allocate the new queue structure and storage area. */
;;;339    	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
000076  f7fffffe          BL       pvPortMalloc
;;;340    
;;;341    	if( pcAllocatedBuffer != NULL )
00007a  b330              CBZ      r0,|L1.202|
;;;342    	{
;;;343    		pxNewQueue = ( Queue_t * ) pcAllocatedBuffer; /*lint !e826 MISRA The buffer cannot be too small because it was dimensioned by sizeof( Queue_t ) + xQueueSizeInBytes. */
00007c  4604              MOV      r4,r0
;;;344    
;;;345    		if( uxItemSize == ( UBaseType_t ) 0 )
00007e  2d00              CMP      r5,#0
;;;346    		{
;;;347    			/* No RAM was allocated for the queue storage area, but PC head
;;;348    			cannot be set to NULL because NULL is used as a key to say the queue
;;;349    			is used as a mutex.  Therefore just set pcHead to point to the queue
;;;350    			as a benign value that is known to be within the memory map. */
;;;351    			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
000080  bf0e              ITEE     EQ
000082  6024              STREQ    r4,[r4,#0]
;;;352    		}
;;;353    		else
;;;354    		{
;;;355    			/* Jump past the queue structure to find the location of the queue
;;;356    			storage area - adding the padding bytes to get a better alignment. */
;;;357    			pxNewQueue->pcHead = pcAllocatedBuffer + sizeof( Queue_t );
000084  f104004c          ADDNE    r0,r4,#0x4c
000088  6020              STRNE    r0,[r4,#0]
00008a  e9c4650f          STRD     r6,r5,[r4,#0x3c]
00008e  f7fffffe          BL       vPortEnterCritical
000092  e9d4120f          LDRD     r1,r2,[r4,#0x3c]
000096  6820              LDR      r0,[r4,#0]
000098  fb010002          MLA      r0,r1,r2,r0
00009c  6060              STR      r0,[r4,#4]
00009e  2000              MOVS     r0,#0
0000a0  63a0              STR      r0,[r4,#0x38]
0000a2  6820              LDR      r0,[r4,#0]
0000a4  1e49              SUBS     r1,r1,#1
0000a6  60a0              STR      r0,[r4,#8]
0000a8  fb010002          MLA      r0,r1,r2,r0
0000ac  60e0              STR      r0,[r4,#0xc]
0000ae  f04f30ff          MOV      r0,#0xffffffff
0000b2  6460              STR      r0,[r4,#0x44]
0000b4  64a0              STR      r0,[r4,#0x48]
0000b6  f1040010          ADD      r0,r4,#0x10
0000ba  f7fffffe          BL       vListInitialise
0000be  f1040024          ADD      r0,r4,#0x24
0000c2  f7fffffe          BL       vListInitialise
0000c6  f7fffffe          BL       vPortExitCritical
                  |L1.202|
;;;358    		}
;;;359    
;;;360    		/* Initialise the queue members as described above where the queue type
;;;361    		is defined. */
;;;362    		pxNewQueue->uxLength = uxQueueLength;
;;;363    		pxNewQueue->uxItemSize = uxItemSize;
;;;364    		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
;;;365    
;;;366    		#if ( configUSE_TRACE_FACILITY == 1 )
;;;367    		{
;;;368    			pxNewQueue->ucQueueType = ucQueueType;
;;;369    		}
;;;370    		#endif /* configUSE_TRACE_FACILITY */
;;;371    
;;;372    		#if( configUSE_QUEUE_SETS == 1 )
;;;373    		{
;;;374    			pxNewQueue->pxQueueSetContainer = NULL;
;;;375    		}
;;;376    		#endif /* configUSE_QUEUE_SETS */
;;;377    
;;;378    		traceQUEUE_CREATE( pxNewQueue );
;;;379    		xReturn = pxNewQueue;
;;;380    	}
;;;381    	else
;;;382    	{
;;;383    		mtCOVERAGE_TEST_MARKER();
;;;384    	}
;;;385    
;;;386    	configASSERT( xReturn );
;;;387    
;;;388    	return xReturn;
0000ca  4620              MOV      r0,r4
;;;389    }
0000cc  bd70              POP      {r4-r6,pc}
;;;390    /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericSend PROC
;;;612    
;;;613    BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
0000ce  e92d43ff          PUSH     {r0-r9,lr}
;;;614    {
;;;615    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
0000d2  2700              MOVS     r7,#0
0000d4  b083              SUB      sp,sp,#0xc            ;614
0000d6  461e              MOV      r6,r3                 ;614
0000d8  4689              MOV      r9,r1                 ;614
0000da  4604              MOV      r4,r0                 ;614
0000dc  46b8              MOV      r8,r7
0000de  1e7d              SUBS     r5,r7,#1
                  |L1.224|
;;;616    TimeOut_t xTimeOut;
;;;617    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;618    
;;;619    	configASSERT( pxQueue );
;;;620    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;621    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;;;622    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;623    	{
;;;624    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;625    	}
;;;626    	#endif
;;;627    
;;;628    
;;;629    	/* This function relaxes the coding standard somewhat to allow return
;;;630    	statements within the function itself.  This is done in the interest
;;;631    	of execution time efficiency. */
;;;632    	for( ;; )
;;;633    	{
;;;634    		taskENTER_CRITICAL();
0000e0  f7fffffe          BL       vPortEnterCritical
;;;635    		{
;;;636    			/* Is there room on the queue now?  The running task must be the
;;;637    			highest priority task wanting to access the queue.  If the head item
;;;638    			in the queue is to be overwritten then it does not matter if the
;;;639    			queue is full. */
;;;640    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
0000e4  6ba0              LDR      r0,[r4,#0x38]
0000e6  6be1              LDR      r1,[r4,#0x3c]
0000e8  4288              CMP      r0,r1
0000ea  d307              BCC      |L1.252|
0000ec  2e02              CMP      r6,#2
0000ee  d005              BEQ      |L1.252|
;;;641    			{
;;;642    				traceQUEUE_SEND( pxQueue );
;;;643    				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;644    
;;;645    				#if ( configUSE_QUEUE_SETS == 1 )
;;;646    				{
;;;647    					if( pxQueue->pxQueueSetContainer != NULL )
;;;648    					{
;;;649    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
;;;650    						{
;;;651    							/* The queue is a member of a queue set, and posting
;;;652    							to the queue set caused a higher priority task to
;;;653    							unblock. A context switch is required. */
;;;654    							queueYIELD_IF_USING_PREEMPTION();
;;;655    						}
;;;656    						else
;;;657    						{
;;;658    							mtCOVERAGE_TEST_MARKER();
;;;659    						}
;;;660    					}
;;;661    					else
;;;662    					{
;;;663    						/* If there was a task waiting for data to arrive on the
;;;664    						queue then unblock it now. */
;;;665    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;666    						{
;;;667    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
;;;668    							{
;;;669    								/* The unblocked task has a priority higher than
;;;670    								our own so yield immediately.  Yes it is ok to
;;;671    								do this from within the critical section - the
;;;672    								kernel takes care of that. */
;;;673    								queueYIELD_IF_USING_PREEMPTION();
;;;674    							}
;;;675    							else
;;;676    							{
;;;677    								mtCOVERAGE_TEST_MARKER();
;;;678    							}
;;;679    						}
;;;680    						else if( xYieldRequired != pdFALSE )
;;;681    						{
;;;682    							/* This path is a special case that will only get
;;;683    							executed if the task was holding multiple mutexes
;;;684    							and the mutexes were given back in an order that is
;;;685    							different to that in which they were taken. */
;;;686    							queueYIELD_IF_USING_PREEMPTION();
;;;687    						}
;;;688    						else
;;;689    						{
;;;690    							mtCOVERAGE_TEST_MARKER();
;;;691    						}
;;;692    					}
;;;693    				}
;;;694    				#else /* configUSE_QUEUE_SETS */
;;;695    				{
;;;696    					/* If there was a task waiting for data to arrive on the
;;;697    					queue then unblock it now. */
;;;698    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;699    					{
;;;700    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
;;;701    						{
;;;702    							/* The unblocked task has a priority higher than
;;;703    							our own so yield immediately.  Yes it is ok to do
;;;704    							this from within the critical section - the kernel
;;;705    							takes care of that. */
;;;706    							queueYIELD_IF_USING_PREEMPTION();
;;;707    						}
;;;708    						else
;;;709    						{
;;;710    							mtCOVERAGE_TEST_MARKER();
;;;711    						}
;;;712    					}
;;;713    					else if( xYieldRequired != pdFALSE )
;;;714    					{
;;;715    						/* This path is a special case that will only get
;;;716    						executed if the task was holding multiple mutexes and
;;;717    						the mutexes were given back in an order that is
;;;718    						different to that in which they were taken. */
;;;719    						queueYIELD_IF_USING_PREEMPTION();
;;;720    					}
;;;721    					else
;;;722    					{
;;;723    						mtCOVERAGE_TEST_MARKER();
;;;724    					}
;;;725    				}
;;;726    				#endif /* configUSE_QUEUE_SETS */
;;;727    
;;;728    				taskEXIT_CRITICAL();
;;;729    				return pdPASS;
;;;730    			}
;;;731    			else
;;;732    			{
;;;733    				if( xTicksToWait == ( TickType_t ) 0 )
0000f0  9805              LDR      r0,[sp,#0x14]
0000f2  2800              CMP      r0,#0
0000f4  d047              BEQ      |L1.390|
;;;734    				{
;;;735    					/* The queue was full and no block time is specified (or
;;;736    					the block time has expired) so leave now. */
;;;737    					taskEXIT_CRITICAL();
;;;738    
;;;739    					/* Return to the original privilege level before exiting
;;;740    					the function. */
;;;741    					traceQUEUE_SEND_FAILED( pxQueue );
;;;742    					return errQUEUE_FULL;
;;;743    				}
;;;744    				else if( xEntryTimeSet == pdFALSE )
0000f6  2f00              CMP      r7,#0
0000f8  d048              BEQ      |L1.396|
0000fa  e04b              B        |L1.404|
                  |L1.252|
0000fc  6c22              LDR      r2,[r4,#0x40]
0000fe  4649              MOV      r1,r9                 ;643
000100  2500              MOVS     r5,#0                 ;643
000102  b182              CBZ      r2,|L1.294|
000104  b1c6              CBZ      r6,|L1.312|
000106  68e0              LDR      r0,[r4,#0xc]          ;643
000108  f7fffffe          BL       __aeabi_memcpy
00010c  68e1              LDR      r1,[r4,#0xc]          ;643
00010e  6c20              LDR      r0,[r4,#0x40]         ;643
000110  1a09              SUBS     r1,r1,r0              ;643
000112  60e1              STR      r1,[r4,#0xc]          ;643
000114  6822              LDR      r2,[r4,#0]            ;643
000116  4291              CMP      r1,r2                 ;643
000118  d202              BCS      |L1.288|
00011a  6861              LDR      r1,[r4,#4]            ;643
00011c  1a08              SUBS     r0,r1,r0              ;643
00011e  60e0              STR      r0,[r4,#0xc]          ;643
                  |L1.288|
000120  2e02              CMP      r6,#2                 ;643
000122  d11b              BNE      |L1.348|
000124  e015              B        |L1.338|
                  |L1.294|
000126  6820              LDR      r0,[r4,#0]            ;643
000128  b9c0              CBNZ     r0,|L1.348|
00012a  6860              LDR      r0,[r4,#4]            ;643
00012c  f7fffffe          BL       xTaskPriorityDisinherit
000130  4605              MOV      r5,r0                 ;643
000132  f8c48004          STR      r8,[r4,#4]            ;643
000136  e011              B        |L1.348|
                  |L1.312|
000138  68a0              LDR      r0,[r4,#8]            ;643
00013a  f7fffffe          BL       __aeabi_memcpy
00013e  6c21              LDR      r1,[r4,#0x40]         ;643
000140  68a0              LDR      r0,[r4,#8]            ;643
000142  4408              ADD      r0,r0,r1              ;643
000144  60a0              STR      r0,[r4,#8]            ;643
000146  6861              LDR      r1,[r4,#4]            ;643
000148  4288              CMP      r0,r1                 ;643
00014a  bf24              ITT      CS                    ;643
00014c  6820              LDRCS    r0,[r4,#0]            ;643
00014e  60a0              STRCS    r0,[r4,#8]            ;643
000150  e004              B        |L1.348|
                  |L1.338|
000152  6ba0              LDR      r0,[r4,#0x38]         ;643
000154  b110              CBZ      r0,|L1.348|
000156  6ba0              LDR      r0,[r4,#0x38]         ;643
000158  1e40              SUBS     r0,r0,#1              ;643
00015a  63a0              STR      r0,[r4,#0x38]         ;643
                  |L1.348|
00015c  6ba0              LDR      r0,[r4,#0x38]         ;643
00015e  1c40              ADDS     r0,r0,#1              ;643
000160  63a0              STR      r0,[r4,#0x38]         ;643
000162  6a60              LDR      r0,[r4,#0x24]         ;698
000164  b130              CBZ      r0,|L1.372|
000166  f1040024          ADD      r0,r4,#0x24           ;700
00016a  f7fffffe          BL       xTaskRemoveFromEventList
00016e  2801              CMP      r0,#1                 ;700
000170  d001              BEQ      |L1.374|
000172  e002              B        |L1.378|
                  |L1.372|
000174  b10d              CBZ      r5,|L1.378|
                  |L1.374|
000176  f7fffffe          BL       vPortYield
                  |L1.378|
00017a  f7fffffe          BL       vPortExitCritical
;;;745    				{
;;;746    					/* The queue was full and a block time was specified so
;;;747    					configure the timeout structure. */
;;;748    					vTaskSetTimeOutState( &xTimeOut );
;;;749    					xEntryTimeSet = pdTRUE;
;;;750    				}
;;;751    				else
;;;752    				{
;;;753    					/* Entry time was already set. */
;;;754    					mtCOVERAGE_TEST_MARKER();
;;;755    				}
;;;756    			}
;;;757    		}
;;;758    		taskEXIT_CRITICAL();
;;;759    
;;;760    		/* Interrupts and other tasks can send to and receive from the queue
;;;761    		now the critical section has been exited. */
;;;762    
;;;763    		vTaskSuspendAll();
;;;764    		prvLockQueue( pxQueue );
;;;765    
;;;766    		/* Update the timeout state to see if it has expired yet. */
;;;767    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;768    		{
;;;769    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;770    			{
;;;771    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;772    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;773    
;;;774    				/* Unlocking the queue means queue events can effect the
;;;775    				event list.  It is possible	that interrupts occurring now
;;;776    				remove this task from the event	list again - but as the
;;;777    				scheduler is suspended the task will go onto the pending
;;;778    				ready last instead of the actual ready list. */
;;;779    				prvUnlockQueue( pxQueue );
;;;780    
;;;781    				/* Resuming the scheduler will move tasks from the pending
;;;782    				ready list into the ready list - so it is feasible that this
;;;783    				task is already in a ready list before it yields - in which
;;;784    				case the yield will not cause a context switch unless there
;;;785    				is also a higher priority task in the pending ready list. */
;;;786    				if( xTaskResumeAll() == pdFALSE )
;;;787    				{
;;;788    					portYIELD_WITHIN_API();
;;;789    				}
;;;790    			}
;;;791    			else
;;;792    			{
;;;793    				/* Try again. */
;;;794    				prvUnlockQueue( pxQueue );
;;;795    				( void ) xTaskResumeAll();
;;;796    			}
;;;797    		}
;;;798    		else
;;;799    		{
;;;800    			/* The timeout has expired. */
;;;801    			prvUnlockQueue( pxQueue );
;;;802    			( void ) xTaskResumeAll();
;;;803    
;;;804    			/* Return to the original privilege level before exiting the
;;;805    			function. */
;;;806    			traceQUEUE_SEND_FAILED( pxQueue );
;;;807    			return errQUEUE_FULL;
;;;808    		}
;;;809    	}
;;;810    }
00017e  b007              ADD      sp,sp,#0x1c
000180  2001              MOVS     r0,#1                 ;729
000182  e8bd83f0          POP      {r4-r9,pc}
                  |L1.390|
000186  f7fffffe          BL       vPortExitCritical
00018a  e04e              B        |L1.554|
                  |L1.396|
00018c  4668              MOV      r0,sp                 ;748
00018e  f7fffffe          BL       vTaskSetTimeOutState
000192  2701              MOVS     r7,#1                 ;749
                  |L1.404|
000194  f7fffffe          BL       vPortExitCritical
000198  f7fffffe          BL       vTaskSuspendAll
00019c  f7fffffe          BL       vPortEnterCritical
0001a0  6c60              LDR      r0,[r4,#0x44]         ;764
0001a2  f1b03fff          CMP      r0,#0xffffffff        ;764
0001a6  bf08              IT       EQ                    ;764
0001a8  f8c48044          STREQ    r8,[r4,#0x44]         ;764
0001ac  6ca0              LDR      r0,[r4,#0x48]         ;764
0001ae  f1b03fff          CMP      r0,#0xffffffff        ;764
0001b2  bf08              IT       EQ                    ;764
0001b4  f8c48048          STREQ    r8,[r4,#0x48]         ;764
0001b8  f7fffffe          BL       vPortExitCritical
0001bc  a905              ADD      r1,sp,#0x14           ;767
0001be  4668              MOV      r0,sp                 ;767
0001c0  f7fffffe          BL       xTaskCheckForTimeOut
0001c4  b3a8              CBZ      r0,|L1.562|
0001c6  f7fffffe          BL       vPortEnterCritical
0001ca  6ca0              LDR      r0,[r4,#0x48]         ;767
0001cc  2800              CMP      r0,#0                 ;767
0001ce  dd0f              BLE      |L1.496|
                  |L1.464|
0001d0  6a60              LDR      r0,[r4,#0x24]         ;767
0001d2  b168              CBZ      r0,|L1.496|
0001d4  f1040024          ADD      r0,r4,#0x24           ;767
0001d8  f7fffffe          BL       xTaskRemoveFromEventList
0001dc  2800              CMP      r0,#0                 ;767
0001de  bf18              IT       NE                    ;767
0001e0  f7fffffe          BLNE     vTaskMissedYield
0001e4  6ca0              LDR      r0,[r4,#0x48]         ;767
0001e6  1e40              SUBS     r0,r0,#1              ;767
0001e8  64a0              STR      r0,[r4,#0x48]         ;767
0001ea  6ca0              LDR      r0,[r4,#0x48]         ;767
0001ec  2800              CMP      r0,#0                 ;767
0001ee  dcef              BGT      |L1.464|
                  |L1.496|
0001f0  64a5              STR      r5,[r4,#0x48]         ;767
0001f2  f7fffffe          BL       vPortExitCritical
0001f6  f7fffffe          BL       vPortEnterCritical
0001fa  6c60              LDR      r0,[r4,#0x44]         ;767
0001fc  2800              CMP      r0,#0                 ;767
0001fe  dd0f              BLE      |L1.544|
                  |L1.512|
000200  6920              LDR      r0,[r4,#0x10]         ;767
000202  b168              CBZ      r0,|L1.544|
000204  f1040010          ADD      r0,r4,#0x10           ;767
000208  f7fffffe          BL       xTaskRemoveFromEventList
00020c  2800              CMP      r0,#0                 ;767
00020e  bf18              IT       NE                    ;767
000210  f7fffffe          BLNE     vTaskMissedYield
000214  6c60              LDR      r0,[r4,#0x44]         ;767
000216  1e40              SUBS     r0,r0,#1              ;767
000218  6460              STR      r0,[r4,#0x44]         ;767
00021a  6c60              LDR      r0,[r4,#0x44]         ;767
00021c  2800              CMP      r0,#0                 ;767
00021e  dcef              BGT      |L1.512|
                  |L1.544|
000220  6465              STR      r5,[r4,#0x44]         ;767
000222  f7fffffe          BL       vPortExitCritical
000226  f7fffffe          BL       xTaskResumeAll
                  |L1.554|
00022a  b007              ADD      sp,sp,#0x1c
00022c  2000              MOVS     r0,#0                 ;807
00022e  e8bd83f0          POP      {r4-r9,pc}
                  |L1.562|
000232  e7ff              B        |L1.564|
                  |L1.564|
000234  f7fffffe          BL       vPortEnterCritical
000238  6ba0              LDR      r0,[r4,#0x38]
00023a  6be1              LDR      r1,[r4,#0x3c]
00023c  4288              CMP      r0,r1
00023e  d10c              BNE      |L1.602|
000240  f7fffffe          BL       vPortExitCritical
000244  f1040010          ADD      r0,r4,#0x10           ;772
000248  9905              LDR      r1,[sp,#0x14]         ;772
00024a  f7fffffe          BL       vTaskPlaceOnEventList
00024e  f7fffffe          BL       vPortEnterCritical
000252  6ca0              LDR      r0,[r4,#0x48]         ;772
000254  2800              CMP      r0,#0                 ;772
000256  dd18              BLE      |L1.650|
000258  e007              B        |L1.618|
                  |L1.602|
00025a  f7fffffe          BL       vPortExitCritical
00025e  f7fffffe          BL       vPortEnterCritical
000262  6ca0              LDR      r0,[r4,#0x48]         ;772
000264  2800              CMP      r0,#0                 ;772
000266  dd42              BLE      |L1.750|
000268  e031              B        |L1.718|
                  |L1.618|
00026a  6a60              LDR      r0,[r4,#0x24]         ;772
00026c  b168              CBZ      r0,|L1.650|
00026e  f1040024          ADD      r0,r4,#0x24           ;772
000272  f7fffffe          BL       xTaskRemoveFromEventList
000276  2800              CMP      r0,#0                 ;772
000278  bf18              IT       NE                    ;772
00027a  f7fffffe          BLNE     vTaskMissedYield
00027e  6ca0              LDR      r0,[r4,#0x48]         ;772
000280  1e41              SUBS     r1,r0,#1              ;772
000282  64a1              STR      r1,[r4,#0x48]         ;772
000284  6ca0              LDR      r0,[r4,#0x48]         ;772
000286  2800              CMP      r0,#0                 ;772
000288  dcef              BGT      |L1.618|
                  |L1.650|
00028a  64a5              STR      r5,[r4,#0x48]         ;772
00028c  f7fffffe          BL       vPortExitCritical
000290  f7fffffe          BL       vPortEnterCritical
000294  6c60              LDR      r0,[r4,#0x44]         ;772
000296  2800              CMP      r0,#0                 ;772
000298  dd0f              BLE      |L1.698|
                  |L1.666|
00029a  6920              LDR      r0,[r4,#0x10]         ;772
00029c  b168              CBZ      r0,|L1.698|
00029e  f1040010          ADD      r0,r4,#0x10           ;772
0002a2  f7fffffe          BL       xTaskRemoveFromEventList
0002a6  2800              CMP      r0,#0                 ;772
0002a8  bf18              IT       NE                    ;772
0002aa  f7fffffe          BLNE     vTaskMissedYield
0002ae  6c60              LDR      r0,[r4,#0x44]         ;772
0002b0  1e41              SUBS     r1,r0,#1              ;772
0002b2  6461              STR      r1,[r4,#0x44]         ;772
0002b4  6c60              LDR      r0,[r4,#0x44]         ;772
0002b6  2800              CMP      r0,#0                 ;772
0002b8  dcef              BGT      |L1.666|
                  |L1.698|
0002ba  6465              STR      r5,[r4,#0x44]         ;772
0002bc  f7fffffe          BL       vPortExitCritical
0002c0  f7fffffe          BL       xTaskResumeAll
0002c4  2800              CMP      r0,#0                 ;786
0002c6  bf08              IT       EQ                    ;788
0002c8  f7fffffe          BLEQ     vPortYield
0002cc  e708              B        |L1.224|
                  |L1.718|
0002ce  6a60              LDR      r0,[r4,#0x24]         ;786
0002d0  b168              CBZ      r0,|L1.750|
0002d2  f1040024          ADD      r0,r4,#0x24           ;786
0002d6  f7fffffe          BL       xTaskRemoveFromEventList
0002da  2800              CMP      r0,#0                 ;786
0002dc  bf18              IT       NE                    ;786
0002de  f7fffffe          BLNE     vTaskMissedYield
0002e2  6ca0              LDR      r0,[r4,#0x48]         ;786
0002e4  1e41              SUBS     r1,r0,#1              ;786
0002e6  64a1              STR      r1,[r4,#0x48]         ;786
0002e8  6ca0              LDR      r0,[r4,#0x48]         ;786
0002ea  2800              CMP      r0,#0                 ;786
0002ec  dcef              BGT      |L1.718|
                  |L1.750|
0002ee  64a5              STR      r5,[r4,#0x48]         ;786
0002f0  f7fffffe          BL       vPortExitCritical
0002f4  f7fffffe          BL       vPortEnterCritical
0002f8  6c60              LDR      r0,[r4,#0x44]         ;786
0002fa  2800              CMP      r0,#0                 ;786
0002fc  dd0f              BLE      |L1.798|
                  |L1.766|
0002fe  6920              LDR      r0,[r4,#0x10]         ;786
000300  b168              CBZ      r0,|L1.798|
000302  f1040010          ADD      r0,r4,#0x10           ;786
000306  f7fffffe          BL       xTaskRemoveFromEventList
00030a  2800              CMP      r0,#0                 ;786
00030c  bf18              IT       NE                    ;786
00030e  f7fffffe          BLNE     vTaskMissedYield
000312  6c60              LDR      r0,[r4,#0x44]         ;786
000314  1e41              SUBS     r1,r0,#1              ;786
000316  6461              STR      r1,[r4,#0x44]         ;786
000318  6c60              LDR      r0,[r4,#0x44]         ;786
00031a  2800              CMP      r0,#0                 ;786
00031c  dcef              BGT      |L1.766|
                  |L1.798|
00031e  6465              STR      r5,[r4,#0x44]         ;786
000320  f7fffffe          BL       vPortExitCritical
000324  f7fffffe          BL       xTaskResumeAll
000328  e6da              B        |L1.224|
;;;811    /*-----------------------------------------------------------*/
                          ENDP

                  xQueueCreateMutex PROC
;;;393    
;;;394    	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
00032a  b510              PUSH     {r4,lr}
;;;395    	{
;;;396    	Queue_t *pxNewQueue;
;;;397    
;;;398    		/* Prevent compiler warnings about unused parameters if
;;;399    		configUSE_TRACE_FACILITY does not equal 1. */
;;;400    		( void ) ucQueueType;
;;;401    
;;;402    		/* Allocate the new queue structure. */
;;;403    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
00032c  204c              MOVS     r0,#0x4c
00032e  f7fffffe          BL       pvPortMalloc
000332  0004              MOVS     r4,r0
;;;404    		if( pxNewQueue != NULL )
000334  d019              BEQ      |L1.874|
;;;405    		{
;;;406    			/* Information required for priority inheritance. */
;;;407    			pxNewQueue->pxMutexHolder = NULL;
000336  2000              MOVS     r0,#0
;;;408    			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
000338  6060              STR      r0,[r4,#4]
;;;409    
;;;410    			/* Queues used as a mutex no data is actually copied into or out
;;;411    			of the queue. */
;;;412    			pxNewQueue->pcWriteTo = NULL;
00033a  6020              STR      r0,[r4,#0]
;;;413    			pxNewQueue->u.pcReadFrom = NULL;
00033c  60a0              STR      r0,[r4,#8]
;;;414    
;;;415    			/* Each mutex has a length of 1 (like a binary semaphore) and
;;;416    			an item size of 0 as nothing is actually copied into or out
;;;417    			of the mutex. */
;;;418    			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
00033e  60e0              STR      r0,[r4,#0xc]
000340  63a0              STR      r0,[r4,#0x38]
;;;419    			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
000342  2101              MOVS     r1,#1
000344  e9c4100f          STRD     r1,r0,[r4,#0x3c]
;;;420    			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
;;;421    			pxNewQueue->xRxLock = queueUNLOCKED;
000348  1e40              SUBS     r0,r0,#1
00034a  6460              STR      r0,[r4,#0x44]
;;;422    			pxNewQueue->xTxLock = queueUNLOCKED;
00034c  64a0              STR      r0,[r4,#0x48]
;;;423    
;;;424    			#if ( configUSE_TRACE_FACILITY == 1 )
;;;425    			{
;;;426    				pxNewQueue->ucQueueType = ucQueueType;
;;;427    			}
;;;428    			#endif
;;;429    
;;;430    			#if ( configUSE_QUEUE_SETS == 1 )
;;;431    			{
;;;432    				pxNewQueue->pxQueueSetContainer = NULL;
;;;433    			}
;;;434    			#endif
;;;435    
;;;436    			/* Ensure the event queues start with the correct state. */
;;;437    			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
00034e  f1040010          ADD      r0,r4,#0x10
000352  f7fffffe          BL       vListInitialise
;;;438    			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
000356  f1040024          ADD      r0,r4,#0x24
00035a  f7fffffe          BL       vListInitialise
;;;439    
;;;440    			traceCREATE_MUTEX( pxNewQueue );
;;;441    
;;;442    			/* Start with the semaphore in the expected state. */
;;;443    			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
00035e  2300              MOVS     r3,#0
000360  461a              MOV      r2,r3
000362  4619              MOV      r1,r3
000364  4620              MOV      r0,r4
000366  f7fffffe          BL       xQueueGenericSend
                  |L1.874|
;;;444    		}
;;;445    		else
;;;446    		{
;;;447    			traceCREATE_MUTEX_FAILED();
;;;448    		}
;;;449    
;;;450    		configASSERT( pxNewQueue );
;;;451    		return pxNewQueue;
00036a  4620              MOV      r0,r4
;;;452    	}
00036c  bd10              POP      {r4,pc}
;;;453    
                          ENDP

                  xQueueCreateCountingSemaphore PROC
;;;585    
;;;586    	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
00036e  e92d41f0          PUSH     {r4-r8,lr}
;;;587    	{
;;;588    	QueueHandle_t xHandle;
;;;589    
;;;590    		configASSERT( uxMaxCount != 0 );
;;;591    		configASSERT( uxInitialCount <= uxMaxCount );
;;;592    
;;;593    		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
000372  4606              MOV      r6,r0
000374  2700              MOVS     r7,#0
000376  460d              MOV      r5,r1                 ;587
000378  463c              MOV      r4,r7                 ;587
00037a  204c              MOVS     r0,#0x4c              ;587
00037c  f7fffffe          BL       pvPortMalloc
000380  2800              CMP      r0,#0                 ;587
000382  bf04              ITT      EQ                    ;587
000384  4620              MOVEQ    r0,r4                 ;587
;;;594    
;;;595    		if( xHandle != NULL )
;;;596    		{
;;;597    			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
;;;598    
;;;599    			traceCREATE_COUNTING_SEMAPHORE();
;;;600    		}
;;;601    		else
;;;602    		{
;;;603    			traceCREATE_COUNTING_SEMAPHORE_FAILED();
;;;604    		}
;;;605    
;;;606    		configASSERT( xHandle );
;;;607    		return xHandle;
;;;608    	}
000386  e8bd81f0          POPEQ    {r4-r8,pc}
00038a  4604              MOV      r4,r0
00038c  6000              STR      r0,[r0,#0]
00038e  e9c4670f          STRD     r6,r7,[r4,#0x3c]
000392  f7fffffe          BL       vPortEnterCritical
000396  e9d4120f          LDRD     r1,r2,[r4,#0x3c]
00039a  6820              LDR      r0,[r4,#0]
00039c  fb010002          MLA      r0,r1,r2,r0
0003a0  6060              STR      r0,[r4,#4]
0003a2  2000              MOVS     r0,#0
0003a4  63a0              STR      r0,[r4,#0x38]
0003a6  6820              LDR      r0,[r4,#0]
0003a8  1e49              SUBS     r1,r1,#1
0003aa  60a0              STR      r0,[r4,#8]
0003ac  fb010002          MLA      r0,r1,r2,r0
0003b0  60e0              STR      r0,[r4,#0xc]
0003b2  f04f30ff          MOV      r0,#0xffffffff
0003b6  6460              STR      r0,[r4,#0x44]
0003b8  64a0              STR      r0,[r4,#0x48]
0003ba  f1040010          ADD      r0,r4,#0x10
0003be  f7fffffe          BL       vListInitialise
0003c2  f1040024          ADD      r0,r4,#0x24
0003c6  f7fffffe          BL       vListInitialise
0003ca  f7fffffe          BL       vPortExitCritical
0003ce  4620              MOV      r0,r4
0003d0  63a5              STR      r5,[r4,#0x38]         ;597
0003d2  e8bd81f0          POP      {r4-r8,pc}
;;;609    
                          ENDP

                  xQueueGenericSendFromISR PROC
;;;1057   
;;;1058   BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
0003d6  e92d41f0          PUSH     {r4-r8,lr}
;;;1059   {
0003da  461d              MOV      r5,r3
0003dc  4616              MOV      r6,r2
0003de  460f              MOV      r7,r1
;;;1060   BaseType_t xReturn;
;;;1061   UBaseType_t uxSavedInterruptStatus;
;;;1062   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
0003e0  4604              MOV      r4,r0
;;;1063   
;;;1064   	configASSERT( pxQueue );
;;;1065   	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1066   	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;;;1067   
;;;1068   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1069   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1070   	above the maximum system call priority are kept permanently enabled, even
;;;1071   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1072   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1073   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1074   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1075   	assigned a priority above the configured maximum system call priority.
;;;1076   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1077   	that have been assigned a priority at or (logically) below the maximum
;;;1078   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1079   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1080   	More information (albeit Cortex-M specific) is provided on the following
;;;1081   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1082   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1083   
;;;1084   	/* Similar to xQueueGenericSend, except without blocking if there is no room
;;;1085   	in the queue.  Also don't directly wake a task that was blocked on a queue
;;;1086   	read, instead return a flag to say whether a context switch is required or
;;;1087   	not (i.e. has a task with a higher priority than us been woken by this
;;;1088   	post). */
;;;1089   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0003e2  f7fffffe          BL       ulPortSetInterruptMask
0003e6  4680              MOV      r8,r0
;;;1090   	{
;;;1091   		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
0003e8  6ba0              LDR      r0,[r4,#0x38]
0003ea  6be1              LDR      r1,[r4,#0x3c]
0003ec  4288              CMP      r0,r1
0003ee  d309              BCC      |L1.1028|
0003f0  2d02              CMP      r5,#2
;;;1092   		{
;;;1093   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1094   
;;;1095   			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
;;;1096   			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
;;;1097   			in a task disinheriting a priority and prvCopyDataToQueue() can be
;;;1098   			called here even though the disinherit function does not check if
;;;1099   			the scheduler is suspended before accessing the ready lists. */
;;;1100   			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;1101   
;;;1102   			/* The event list is not altered if the queue is locked.  This will
;;;1103   			be done when the queue is unlocked later. */
;;;1104   			if( pxQueue->xTxLock == queueUNLOCKED )
;;;1105   			{
;;;1106   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1107   				{
;;;1108   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1109   					{
;;;1110   						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
;;;1111   						{
;;;1112   							/* The queue is a member of a queue set, and posting
;;;1113   							to the queue set caused a higher priority task to
;;;1114   							unblock.  A context switch is required. */
;;;1115   							if( pxHigherPriorityTaskWoken != NULL )
;;;1116   							{
;;;1117   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1118   							}
;;;1119   							else
;;;1120   							{
;;;1121   								mtCOVERAGE_TEST_MARKER();
;;;1122   							}
;;;1123   						}
;;;1124   						else
;;;1125   						{
;;;1126   							mtCOVERAGE_TEST_MARKER();
;;;1127   						}
;;;1128   					}
;;;1129   					else
;;;1130   					{
;;;1131   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1132   						{
;;;1133   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1134   							{
;;;1135   								/* The task waiting has a higher priority so
;;;1136   								record that a context switch is required. */
;;;1137   								if( pxHigherPriorityTaskWoken != NULL )
;;;1138   								{
;;;1139   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1140   								}
;;;1141   								else
;;;1142   								{
;;;1143   									mtCOVERAGE_TEST_MARKER();
;;;1144   								}
;;;1145   							}
;;;1146   							else
;;;1147   							{
;;;1148   								mtCOVERAGE_TEST_MARKER();
;;;1149   							}
;;;1150   						}
;;;1151   						else
;;;1152   						{
;;;1153   							mtCOVERAGE_TEST_MARKER();
;;;1154   						}
;;;1155   					}
;;;1156   				}
;;;1157   				#else /* configUSE_QUEUE_SETS */
;;;1158   				{
;;;1159   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1160   					{
;;;1161   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1162   						{
;;;1163   							/* The task waiting has a higher priority so record that a
;;;1164   							context	switch is required. */
;;;1165   							if( pxHigherPriorityTaskWoken != NULL )
;;;1166   							{
;;;1167   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1168   							}
;;;1169   							else
;;;1170   							{
;;;1171   								mtCOVERAGE_TEST_MARKER();
;;;1172   							}
;;;1173   						}
;;;1174   						else
;;;1175   						{
;;;1176   							mtCOVERAGE_TEST_MARKER();
;;;1177   						}
;;;1178   					}
;;;1179   					else
;;;1180   					{
;;;1181   						mtCOVERAGE_TEST_MARKER();
;;;1182   					}
;;;1183   				}
;;;1184   				#endif /* configUSE_QUEUE_SETS */
;;;1185   			}
;;;1186   			else
;;;1187   			{
;;;1188   				/* Increment the lock count so the task that unlocks the queue
;;;1189   				knows that data was posted while it was locked. */
;;;1190   				++( pxQueue->xTxLock );
;;;1191   			}
;;;1192   
;;;1193   			xReturn = pdPASS;
;;;1194   		}
;;;1195   		else
;;;1196   		{
;;;1197   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1198   			xReturn = errQUEUE_FULL;
0003f2  bf18              IT       NE
0003f4  2400              MOVNE    r4,#0
0003f6  d005              BEQ      |L1.1028|
                  |L1.1016|
;;;1199   		}
;;;1200   	}
;;;1201   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0003f8  4640              MOV      r0,r8
0003fa  f7fffffe          BL       vPortClearInterruptMask
;;;1202   
;;;1203   	return xReturn;
0003fe  4620              MOV      r0,r4
;;;1204   }
000400  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1028|
000404  6c22              LDR      r2,[r4,#0x40]
000406  4639              MOV      r1,r7                 ;1100
000408  b18a              CBZ      r2,|L1.1070|
00040a  b1c5              CBZ      r5,|L1.1086|
00040c  68e0              LDR      r0,[r4,#0xc]          ;1100
00040e  f7fffffe          BL       __aeabi_memcpy
000412  6c21              LDR      r1,[r4,#0x40]         ;1100
000414  68e0              LDR      r0,[r4,#0xc]          ;1100
000416  1a40              SUBS     r0,r0,r1              ;1100
000418  60e0              STR      r0,[r4,#0xc]          ;1100
00041a  6821              LDR      r1,[r4,#0]            ;1100
00041c  4288              CMP      r0,r1                 ;1100
00041e  d203              BCS      |L1.1064|
000420  6c21              LDR      r1,[r4,#0x40]         ;1100
000422  6860              LDR      r0,[r4,#4]            ;1100
000424  1a40              SUBS     r0,r0,r1              ;1100
000426  60e0              STR      r0,[r4,#0xc]          ;1100
                  |L1.1064|
000428  2d02              CMP      r5,#2                 ;1100
00042a  d11a              BNE      |L1.1122|
00042c  e014              B        |L1.1112|
                  |L1.1070|
00042e  6820              LDR      r0,[r4,#0]            ;1100
000430  b9b8              CBNZ     r0,|L1.1122|
000432  6860              LDR      r0,[r4,#4]            ;1100
000434  f7fffffe          BL       xTaskPriorityDisinherit
000438  2000              MOVS     r0,#0                 ;1100
00043a  6060              STR      r0,[r4,#4]            ;1100
00043c  e011              B        |L1.1122|
                  |L1.1086|
00043e  68a0              LDR      r0,[r4,#8]            ;1100
000440  f7fffffe          BL       __aeabi_memcpy
000444  6c21              LDR      r1,[r4,#0x40]         ;1100
000446  68a0              LDR      r0,[r4,#8]            ;1100
000448  4408              ADD      r0,r0,r1              ;1100
00044a  60a0              STR      r0,[r4,#8]            ;1100
00044c  6861              LDR      r1,[r4,#4]            ;1100
00044e  4288              CMP      r0,r1                 ;1100
000450  bf24              ITT      CS                    ;1100
000452  6820              LDRCS    r0,[r4,#0]            ;1100
000454  60a0              STRCS    r0,[r4,#8]            ;1100
000456  e004              B        |L1.1122|
                  |L1.1112|
000458  6ba0              LDR      r0,[r4,#0x38]         ;1100
00045a  b110              CBZ      r0,|L1.1122|
00045c  6ba0              LDR      r0,[r4,#0x38]         ;1100
00045e  1e40              SUBS     r0,r0,#1              ;1100
000460  63a0              STR      r0,[r4,#0x38]         ;1100
                  |L1.1122|
000462  6ba0              LDR      r0,[r4,#0x38]         ;1100
000464  1c40              ADDS     r0,r0,#1              ;1100
000466  63a0              STR      r0,[r4,#0x38]         ;1100
000468  6ca0              LDR      r0,[r4,#0x48]         ;1104
00046a  f1b03fff          CMP      r0,#0xffffffff        ;1104
00046e  d004              BEQ      |L1.1146|
000470  6ca0              LDR      r0,[r4,#0x48]         ;1190
000472  1c40              ADDS     r0,r0,#1              ;1190
000474  64a0              STR      r0,[r4,#0x48]         ;1190
                  |L1.1142|
000476  2401              MOVS     r4,#1                 ;1193
000478  e7be              B        |L1.1016|
                  |L1.1146|
00047a  6a60              LDR      r0,[r4,#0x24]         ;1159
00047c  2800              CMP      r0,#0                 ;1159
00047e  d0fa              BEQ      |L1.1142|
000480  f1040024          ADD      r0,r4,#0x24           ;1161
000484  f7fffffe          BL       xTaskRemoveFromEventList
000488  2800              CMP      r0,#0                 ;1161
00048a  bf1e              ITTT     NE                    ;1165
00048c  2e00              CMPNE    r6,#0                 ;1165
00048e  2001              MOVNE    r0,#1                 ;1167
000490  6030              STRNE    r0,[r6,#0]            ;1167
000492  e7f0              B        |L1.1142|
;;;1205   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGiveFromISR PROC
;;;1206   
;;;1207   BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
000494  b570              PUSH     {r4-r6,lr}
;;;1208   {
000496  460d              MOV      r5,r1
;;;1209   BaseType_t xReturn;
;;;1210   UBaseType_t uxSavedInterruptStatus;
;;;1211   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000498  4604              MOV      r4,r0
;;;1212   
;;;1213   	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
;;;1214   	item size is 0.  Don't directly wake a task that was blocked on a queue
;;;1215   	read, instead return a flag to say whether a context switch is required or
;;;1216   	not (i.e. has a task with a higher priority than us been woken by this
;;;1217   	post). */
;;;1218   
;;;1219   	configASSERT( pxQueue );
;;;1220   
;;;1221   	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
;;;1222   	if the item size is not 0. */
;;;1223   	configASSERT( pxQueue->uxItemSize == 0 );
;;;1224   
;;;1225   	/* Normally a mutex would not be given from an interrupt, and doing so is
;;;1226   	definitely wrong if there is a mutex holder as priority inheritance makes no
;;;1227   	sense for an interrupts, only tasks. */
;;;1228   	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
;;;1229   
;;;1230   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1231   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1232   	above the maximum system call priority are kept permanently enabled, even
;;;1233   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1234   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1235   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1236   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1237   	assigned a priority above the configured maximum system call priority.
;;;1238   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1239   	that have been assigned a priority at or (logically) below the maximum
;;;1240   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1241   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1242   	More information (albeit Cortex-M specific) is provided on the following
;;;1243   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1244   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1245   
;;;1246   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00049a  f7fffffe          BL       ulPortSetInterruptMask
00049e  4606              MOV      r6,r0
;;;1247   	{
;;;1248   		/* When the queue is used to implement a semaphore no data is ever
;;;1249   		moved through the queue but it is still valid to see if the queue 'has
;;;1250   		space'. */
;;;1251   		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
0004a0  6ba0              LDR      r0,[r4,#0x38]
0004a2  6be1              LDR      r1,[r4,#0x3c]
0004a4  4288              CMP      r0,r1
;;;1252   		{
;;;1253   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1254   
;;;1255   			/* A task can only have an inherited priority if it is a mutex
;;;1256   			holder - and if there is a mutex holder then the mutex cannot be
;;;1257   			given from an ISR.  As this is the ISR version of the function it
;;;1258   			can be assumed there is no mutex holder and no need to determine if
;;;1259   			priority disinheritance is needed.  Simply increase the count of
;;;1260   			messages (semaphores) available. */
;;;1261   			++( pxQueue->uxMessagesWaiting );
;;;1262   
;;;1263   			/* The event list is not altered if the queue is locked.  This will
;;;1264   			be done when the queue is unlocked later. */
;;;1265   			if( pxQueue->xTxLock == queueUNLOCKED )
;;;1266   			{
;;;1267   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1268   				{
;;;1269   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1270   					{
;;;1271   						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
;;;1272   						{
;;;1273   							/* The semaphore is a member of a queue set, and
;;;1274   							posting	to the queue set caused a higher priority
;;;1275   							task to	unblock.  A context switch is required. */
;;;1276   							if( pxHigherPriorityTaskWoken != NULL )
;;;1277   							{
;;;1278   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1279   							}
;;;1280   							else
;;;1281   							{
;;;1282   								mtCOVERAGE_TEST_MARKER();
;;;1283   							}
;;;1284   						}
;;;1285   						else
;;;1286   						{
;;;1287   							mtCOVERAGE_TEST_MARKER();
;;;1288   						}
;;;1289   					}
;;;1290   					else
;;;1291   					{
;;;1292   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1293   						{
;;;1294   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1295   							{
;;;1296   								/* The task waiting has a higher priority so
;;;1297   								record that a context switch is required. */
;;;1298   								if( pxHigherPriorityTaskWoken != NULL )
;;;1299   								{
;;;1300   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1301   								}
;;;1302   								else
;;;1303   								{
;;;1304   									mtCOVERAGE_TEST_MARKER();
;;;1305   								}
;;;1306   							}
;;;1307   							else
;;;1308   							{
;;;1309   								mtCOVERAGE_TEST_MARKER();
;;;1310   							}
;;;1311   						}
;;;1312   						else
;;;1313   						{
;;;1314   							mtCOVERAGE_TEST_MARKER();
;;;1315   						}
;;;1316   					}
;;;1317   				}
;;;1318   				#else /* configUSE_QUEUE_SETS */
;;;1319   				{
;;;1320   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1321   					{
;;;1322   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1323   						{
;;;1324   							/* The task waiting has a higher priority so record that a
;;;1325   							context	switch is required. */
;;;1326   							if( pxHigherPriorityTaskWoken != NULL )
;;;1327   							{
;;;1328   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1329   							}
;;;1330   							else
;;;1331   							{
;;;1332   								mtCOVERAGE_TEST_MARKER();
;;;1333   							}
;;;1334   						}
;;;1335   						else
;;;1336   						{
;;;1337   							mtCOVERAGE_TEST_MARKER();
;;;1338   						}
;;;1339   					}
;;;1340   					else
;;;1341   					{
;;;1342   						mtCOVERAGE_TEST_MARKER();
;;;1343   					}
;;;1344   				}
;;;1345   				#endif /* configUSE_QUEUE_SETS */
;;;1346   			}
;;;1347   			else
;;;1348   			{
;;;1349   				/* Increment the lock count so the task that unlocks the queue
;;;1350   				knows that data was posted while it was locked. */
;;;1351   				++( pxQueue->xTxLock );
;;;1352   			}
;;;1353   
;;;1354   			xReturn = pdPASS;
;;;1355   		}
;;;1356   		else
;;;1357   		{
;;;1358   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1359   			xReturn = errQUEUE_FULL;
0004a6  bf28              IT       CS
0004a8  2400              MOVCS    r4,#0
0004aa  d20a              BCS      |L1.1218|
0004ac  6ba0              LDR      r0,[r4,#0x38]         ;1261
0004ae  1c40              ADDS     r0,r0,#1              ;1261
0004b0  63a0              STR      r0,[r4,#0x38]         ;1261
0004b2  6ca0              LDR      r0,[r4,#0x48]         ;1265
0004b4  f1b03fff          CMP      r0,#0xffffffff        ;1265
0004b8  d008              BEQ      |L1.1228|
0004ba  6ca0              LDR      r0,[r4,#0x48]         ;1351
0004bc  1c40              ADDS     r0,r0,#1              ;1351
0004be  64a0              STR      r0,[r4,#0x48]         ;1351
                  |L1.1216|
0004c0  2401              MOVS     r4,#1                 ;1354
                  |L1.1218|
;;;1360   		}
;;;1361   	}
;;;1362   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0004c2  4630              MOV      r0,r6
0004c4  f7fffffe          BL       vPortClearInterruptMask
;;;1363   
;;;1364   	return xReturn;
0004c8  4620              MOV      r0,r4
;;;1365   }
0004ca  bd70              POP      {r4-r6,pc}
                  |L1.1228|
0004cc  6a60              LDR      r0,[r4,#0x24]         ;1320
0004ce  2800              CMP      r0,#0                 ;1320
0004d0  d0f6              BEQ      |L1.1216|
0004d2  f1040024          ADD      r0,r4,#0x24           ;1322
0004d6  f7fffffe          BL       xTaskRemoveFromEventList
0004da  2800              CMP      r0,#0                 ;1322
0004dc  bf1e              ITTT     NE                    ;1326
0004de  2d00              CMPNE    r5,#0                 ;1326
0004e0  2001              MOVNE    r0,#1                 ;1328
0004e2  6028              STRNE    r0,[r5,#0]            ;1328
0004e4  e7ec              B        |L1.1216|
;;;1366   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericReceive PROC
;;;1367   
;;;1368   BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
0004e6  e92d43ff          PUSH     {r0-r9,lr}
;;;1369   {
;;;1370   BaseType_t xEntryTimeSet = pdFALSE;
0004ea  2700              MOVS     r7,#0
0004ec  b083              SUB      sp,sp,#0xc            ;1369
0004ee  4699              MOV      r9,r3                 ;1369
0004f0  460e              MOV      r6,r1                 ;1369
;;;1371   TimeOut_t xTimeOut;
;;;1372   int8_t *pcOriginalReadPosition;
;;;1373   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
0004f2  4604              MOV      r4,r0
0004f4  46b8              MOV      r8,r7
0004f6  1e7d              SUBS     r5,r7,#1
                  |L1.1272|
;;;1374   
;;;1375   	configASSERT( pxQueue );
;;;1376   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1377   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1378   	{
;;;1379   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;1380   	}
;;;1381   	#endif
;;;1382   
;;;1383   	/* This function relaxes the coding standard somewhat to allow return
;;;1384   	statements within the function itself.  This is done in the interest
;;;1385   	of execution time efficiency. */
;;;1386   
;;;1387   	for( ;; )
;;;1388   	{
;;;1389   		taskENTER_CRITICAL();
0004f8  f7fffffe          BL       vPortEnterCritical
;;;1390   		{
;;;1391   			/* Is there data in the queue now?  To be running the calling task
;;;1392   			must be	the highest priority task wanting to access the queue. */
;;;1393   			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
0004fc  6ba0              LDR      r0,[r4,#0x38]
0004fe  2800              CMP      r0,#0
000500  d032              BEQ      |L1.1384|
000502  68e5              LDR      r5,[r4,#0xc]
000504  6c22              LDR      r2,[r4,#0x40]
;;;1394   			{
;;;1395   				/* Remember the read position in case the queue is only being
;;;1396   				peeked. */
;;;1397   				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
;;;1398   
;;;1399   				prvCopyDataFromQueue( pxQueue, pvBuffer );
000506  4630              MOV      r0,r6
000508  b142              CBZ      r2,|L1.1308|
00050a  18a9              ADDS     r1,r5,r2
00050c  60e1              STR      r1,[r4,#0xc]
00050e  6863              LDR      r3,[r4,#4]
000510  4299              CMP      r1,r3
000512  bf24              ITT      CS
000514  6821              LDRCS    r1,[r4,#0]
000516  60e1              STRCS    r1,[r4,#0xc]
000518  f7fffffe          BL       __aeabi_memcpy
                  |L1.1308|
;;;1400   
;;;1401   				if( xJustPeeking == pdFALSE )
00051c  f1b90f00          CMP      r9,#0
000520  d010              BEQ      |L1.1348|
;;;1402   				{
;;;1403   					traceQUEUE_RECEIVE( pxQueue );
;;;1404   
;;;1405   					/* Actually removing data, not just peeking. */
;;;1406   					--( pxQueue->uxMessagesWaiting );
;;;1407   
;;;1408   					#if ( configUSE_MUTEXES == 1 )
;;;1409   					{
;;;1410   						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1411   						{
;;;1412   							/* Record the information required to implement
;;;1413   							priority inheritance should it become necessary. */
;;;1414   							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
;;;1415   						}
;;;1416   						else
;;;1417   						{
;;;1418   							mtCOVERAGE_TEST_MARKER();
;;;1419   						}
;;;1420   					}
;;;1421   					#endif /* configUSE_MUTEXES */
;;;1422   
;;;1423   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1424   					{
;;;1425   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
;;;1426   						{
;;;1427   							queueYIELD_IF_USING_PREEMPTION();
;;;1428   						}
;;;1429   						else
;;;1430   						{
;;;1431   							mtCOVERAGE_TEST_MARKER();
;;;1432   						}
;;;1433   					}
;;;1434   					else
;;;1435   					{
;;;1436   						mtCOVERAGE_TEST_MARKER();
;;;1437   					}
;;;1438   				}
;;;1439   				else
;;;1440   				{
;;;1441   					traceQUEUE_PEEK( pxQueue );
;;;1442   
;;;1443   					/* The data is not being removed, so reset the read
;;;1444   					pointer. */
;;;1445   					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
;;;1446   
;;;1447   					/* The data is being left in the queue, so see if there are
;;;1448   					any other tasks waiting for the data. */
;;;1449   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000522  60e5              STR      r5,[r4,#0xc]
000524  6a60              LDR      r0,[r4,#0x24]
000526  b138              CBZ      r0,|L1.1336|
;;;1450   					{
;;;1451   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000528  f1040024          ADD      r0,r4,#0x24
00052c  f7fffffe          BL       xTaskRemoveFromEventList
000530  b110              CBZ      r0,|L1.1336|
;;;1452   						{
;;;1453   							/* The task waiting has a higher priority than this task. */
;;;1454   							queueYIELD_IF_USING_PREEMPTION();
000532  bf00              NOP      
                  |L1.1332|
000534  f7fffffe          BL       vPortYield
                  |L1.1336|
;;;1455   						}
;;;1456   						else
;;;1457   						{
;;;1458   							mtCOVERAGE_TEST_MARKER();
;;;1459   						}
;;;1460   					}
;;;1461   					else
;;;1462   					{
;;;1463   						mtCOVERAGE_TEST_MARKER();
;;;1464   					}
;;;1465   				}
;;;1466   
;;;1467   				taskEXIT_CRITICAL();
000538  f7fffffe          BL       vPortExitCritical
;;;1468   				return pdPASS;
;;;1469   			}
;;;1470   			else
;;;1471   			{
;;;1472   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1473   				{
;;;1474   					/* The queue was empty and no block time is specified (or
;;;1475   					the block time has expired) so leave now. */
;;;1476   					taskEXIT_CRITICAL();
;;;1477   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1478   					return errQUEUE_EMPTY;
;;;1479   				}
;;;1480   				else if( xEntryTimeSet == pdFALSE )
;;;1481   				{
;;;1482   					/* The queue was empty and a block time was specified so
;;;1483   					configure the timeout structure. */
;;;1484   					vTaskSetTimeOutState( &xTimeOut );
;;;1485   					xEntryTimeSet = pdTRUE;
;;;1486   				}
;;;1487   				else
;;;1488   				{
;;;1489   					/* Entry time was already set. */
;;;1490   					mtCOVERAGE_TEST_MARKER();
;;;1491   				}
;;;1492   			}
;;;1493   		}
;;;1494   		taskEXIT_CRITICAL();
;;;1495   
;;;1496   		/* Interrupts and other tasks can send to and receive from the queue
;;;1497   		now the critical section has been exited. */
;;;1498   
;;;1499   		vTaskSuspendAll();
;;;1500   		prvLockQueue( pxQueue );
;;;1501   
;;;1502   		/* Update the timeout state to see if it has expired yet. */
;;;1503   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1504   		{
;;;1505   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1506   			{
;;;1507   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1508   
;;;1509   				#if ( configUSE_MUTEXES == 1 )
;;;1510   				{
;;;1511   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1512   					{
;;;1513   						taskENTER_CRITICAL();
;;;1514   						{
;;;1515   							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
;;;1516   						}
;;;1517   						taskEXIT_CRITICAL();
;;;1518   					}
;;;1519   					else
;;;1520   					{
;;;1521   						mtCOVERAGE_TEST_MARKER();
;;;1522   					}
;;;1523   				}
;;;1524   				#endif
;;;1525   
;;;1526   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1527   				prvUnlockQueue( pxQueue );
;;;1528   				if( xTaskResumeAll() == pdFALSE )
;;;1529   				{
;;;1530   					portYIELD_WITHIN_API();
;;;1531   				}
;;;1532   				else
;;;1533   				{
;;;1534   					mtCOVERAGE_TEST_MARKER();
;;;1535   				}
;;;1536   			}
;;;1537   			else
;;;1538   			{
;;;1539   				/* Try again. */
;;;1540   				prvUnlockQueue( pxQueue );
;;;1541   				( void ) xTaskResumeAll();
;;;1542   			}
;;;1543   		}
;;;1544   		else
;;;1545   		{
;;;1546   			prvUnlockQueue( pxQueue );
;;;1547   			( void ) xTaskResumeAll();
;;;1548   			traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1549   			return errQUEUE_EMPTY;
;;;1550   		}
;;;1551   	}
;;;1552   }
00053c  b007              ADD      sp,sp,#0x1c
00053e  2001              MOVS     r0,#1                 ;1468
000540  e8bd83f0          POP      {r4-r9,pc}
                  |L1.1348|
000544  6ba0              LDR      r0,[r4,#0x38]         ;1406
000546  1e40              SUBS     r0,r0,#1              ;1406
000548  63a0              STR      r0,[r4,#0x38]         ;1406
00054a  6820              LDR      r0,[r4,#0]            ;1410
00054c  b910              CBNZ     r0,|L1.1364|
00054e  f7fffffe          BL       pvTaskIncrementMutexHeldCount
000552  6060              STR      r0,[r4,#4]            ;1414
                  |L1.1364|
000554  6920              LDR      r0,[r4,#0x10]         ;1423
000556  2800              CMP      r0,#0                 ;1423
000558  d0ee              BEQ      |L1.1336|
00055a  f1040010          ADD      r0,r4,#0x10           ;1425
00055e  f7fffffe          BL       xTaskRemoveFromEventList
000562  2801              CMP      r0,#1                 ;1425
000564  d0e6              BEQ      |L1.1332|
000566  e7e7              B        |L1.1336|
                  |L1.1384|
000568  9805              LDR      r0,[sp,#0x14]         ;1472
00056a  b108              CBZ      r0,|L1.1392|
00056c  b11f              CBZ      r7,|L1.1398|
00056e  e006              B        |L1.1406|
                  |L1.1392|
000570  f7fffffe          BL       vPortExitCritical
000574  e04e              B        |L1.1556|
                  |L1.1398|
000576  4668              MOV      r0,sp                 ;1484
000578  f7fffffe          BL       vTaskSetTimeOutState
00057c  2701              MOVS     r7,#1                 ;1485
                  |L1.1406|
00057e  f7fffffe          BL       vPortExitCritical
000582  f7fffffe          BL       vTaskSuspendAll
000586  f7fffffe          BL       vPortEnterCritical
00058a  6c60              LDR      r0,[r4,#0x44]         ;1500
00058c  f1b03fff          CMP      r0,#0xffffffff        ;1500
000590  bf08              IT       EQ                    ;1500
000592  f8c48044          STREQ    r8,[r4,#0x44]         ;1500
000596  6ca0              LDR      r0,[r4,#0x48]         ;1500
000598  f1b03fff          CMP      r0,#0xffffffff        ;1500
00059c  bf08              IT       EQ                    ;1500
00059e  f8c48048          STREQ    r8,[r4,#0x48]         ;1500
0005a2  f7fffffe          BL       vPortExitCritical
0005a6  a905              ADD      r1,sp,#0x14           ;1503
0005a8  4668              MOV      r0,sp                 ;1503
0005aa  f7fffffe          BL       xTaskCheckForTimeOut
0005ae  b3a8              CBZ      r0,|L1.1564|
0005b0  f7fffffe          BL       vPortEnterCritical
0005b4  6ca0              LDR      r0,[r4,#0x48]         ;1503
0005b6  2800              CMP      r0,#0                 ;1503
0005b8  dd0f              BLE      |L1.1498|
                  |L1.1466|
0005ba  6a60              LDR      r0,[r4,#0x24]         ;1503
0005bc  b168              CBZ      r0,|L1.1498|
0005be  f1040024          ADD      r0,r4,#0x24           ;1503
0005c2  f7fffffe          BL       xTaskRemoveFromEventList
0005c6  2800              CMP      r0,#0                 ;1503
0005c8  bf18              IT       NE                    ;1503
0005ca  f7fffffe          BLNE     vTaskMissedYield
0005ce  6ca0              LDR      r0,[r4,#0x48]         ;1503
0005d0  1e40              SUBS     r0,r0,#1              ;1503
0005d2  64a0              STR      r0,[r4,#0x48]         ;1503
0005d4  6ca0              LDR      r0,[r4,#0x48]         ;1503
0005d6  2800              CMP      r0,#0                 ;1503
0005d8  dcef              BGT      |L1.1466|
                  |L1.1498|
0005da  64a5              STR      r5,[r4,#0x48]         ;1503
0005dc  f7fffffe          BL       vPortExitCritical
0005e0  f7fffffe          BL       vPortEnterCritical
0005e4  6c60              LDR      r0,[r4,#0x44]         ;1503
0005e6  2800              CMP      r0,#0                 ;1503
0005e8  dd0f              BLE      |L1.1546|
                  |L1.1514|
0005ea  6920              LDR      r0,[r4,#0x10]         ;1503
0005ec  b168              CBZ      r0,|L1.1546|
0005ee  f1040010          ADD      r0,r4,#0x10           ;1503
0005f2  f7fffffe          BL       xTaskRemoveFromEventList
0005f6  2800              CMP      r0,#0                 ;1503
0005f8  bf18              IT       NE                    ;1503
0005fa  f7fffffe          BLNE     vTaskMissedYield
0005fe  6c60              LDR      r0,[r4,#0x44]         ;1503
000600  1e40              SUBS     r0,r0,#1              ;1503
000602  6460              STR      r0,[r4,#0x44]         ;1503
000604  6c60              LDR      r0,[r4,#0x44]         ;1503
000606  2800              CMP      r0,#0                 ;1503
000608  dcef              BGT      |L1.1514|
                  |L1.1546|
00060a  6465              STR      r5,[r4,#0x44]         ;1503
00060c  f7fffffe          BL       vPortExitCritical
000610  f7fffffe          BL       xTaskResumeAll
                  |L1.1556|
000614  b007              ADD      sp,sp,#0x1c
000616  2000              MOVS     r0,#0                 ;1549
000618  e8bd83f0          POP      {r4-r9,pc}
                  |L1.1564|
00061c  e7ff              B        |L1.1566|
                  |L1.1566|
00061e  f7fffffe          BL       vPortEnterCritical
000622  6ba0              LDR      r0,[r4,#0x38]
000624  b138              CBZ      r0,|L1.1590|
000626  f7fffffe          BL       vPortExitCritical
00062a  f7fffffe          BL       vPortEnterCritical
00062e  6ca0              LDR      r0,[r4,#0x48]
000630  2800              CMP      r0,#0
000632  dd57              BLE      |L1.1764|
000634  e046              B        |L1.1732|
                  |L1.1590|
000636  f7fffffe          BL       vPortExitCritical
00063a  6820              LDR      r0,[r4,#0]
00063c  b930              CBNZ     r0,|L1.1612|
00063e  f7fffffe          BL       vPortEnterCritical
000642  6860              LDR      r0,[r4,#4]            ;1515
000644  f7fffffe          BL       vTaskPriorityInherit
000648  f7fffffe          BL       vPortExitCritical
                  |L1.1612|
00064c  f1040024          ADD      r0,r4,#0x24           ;1526
000650  9905              LDR      r1,[sp,#0x14]         ;1526
000652  f7fffffe          BL       vTaskPlaceOnEventList
000656  f7fffffe          BL       vPortEnterCritical
00065a  6ca0              LDR      r0,[r4,#0x48]         ;1526
00065c  2800              CMP      r0,#0                 ;1526
00065e  dd0f              BLE      |L1.1664|
                  |L1.1632|
000660  6a60              LDR      r0,[r4,#0x24]         ;1526
000662  b168              CBZ      r0,|L1.1664|
000664  f1040024          ADD      r0,r4,#0x24           ;1526
000668  f7fffffe          BL       xTaskRemoveFromEventList
00066c  2800              CMP      r0,#0                 ;1526
00066e  bf18              IT       NE                    ;1526
000670  f7fffffe          BLNE     vTaskMissedYield
000674  6ca0              LDR      r0,[r4,#0x48]         ;1526
000676  1e41              SUBS     r1,r0,#1              ;1526
000678  64a1              STR      r1,[r4,#0x48]         ;1526
00067a  6ca0              LDR      r0,[r4,#0x48]         ;1526
00067c  2800              CMP      r0,#0                 ;1526
00067e  dcef              BGT      |L1.1632|
                  |L1.1664|
000680  64a5              STR      r5,[r4,#0x48]         ;1526
000682  f7fffffe          BL       vPortExitCritical
000686  f7fffffe          BL       vPortEnterCritical
00068a  6c60              LDR      r0,[r4,#0x44]         ;1526
00068c  2800              CMP      r0,#0                 ;1526
00068e  dd0f              BLE      |L1.1712|
                  |L1.1680|
000690  6920              LDR      r0,[r4,#0x10]         ;1526
000692  b168              CBZ      r0,|L1.1712|
000694  f1040010          ADD      r0,r4,#0x10           ;1526
000698  f7fffffe          BL       xTaskRemoveFromEventList
00069c  2800              CMP      r0,#0                 ;1526
00069e  bf18              IT       NE                    ;1526
0006a0  f7fffffe          BLNE     vTaskMissedYield
0006a4  6c60              LDR      r0,[r4,#0x44]         ;1526
0006a6  1e41              SUBS     r1,r0,#1              ;1526
0006a8  6461              STR      r1,[r4,#0x44]         ;1526
0006aa  6c60              LDR      r0,[r4,#0x44]         ;1526
0006ac  2800              CMP      r0,#0                 ;1526
0006ae  dcef              BGT      |L1.1680|
                  |L1.1712|
0006b0  6465              STR      r5,[r4,#0x44]         ;1526
0006b2  f7fffffe          BL       vPortExitCritical
0006b6  f7fffffe          BL       xTaskResumeAll
0006ba  2800              CMP      r0,#0                 ;1528
0006bc  bf08              IT       EQ                    ;1530
0006be  f7fffffe          BLEQ     vPortYield
0006c2  e719              B        |L1.1272|
                  |L1.1732|
0006c4  6a60              LDR      r0,[r4,#0x24]         ;1528
0006c6  b168              CBZ      r0,|L1.1764|
0006c8  f1040024          ADD      r0,r4,#0x24           ;1528
0006cc  f7fffffe          BL       xTaskRemoveFromEventList
0006d0  2800              CMP      r0,#0                 ;1528
0006d2  bf18              IT       NE                    ;1528
0006d4  f7fffffe          BLNE     vTaskMissedYield
0006d8  6ca0              LDR      r0,[r4,#0x48]         ;1528
0006da  1e41              SUBS     r1,r0,#1              ;1528
0006dc  64a1              STR      r1,[r4,#0x48]         ;1528
0006de  6ca0              LDR      r0,[r4,#0x48]         ;1528
0006e0  2800              CMP      r0,#0                 ;1528
0006e2  dcef              BGT      |L1.1732|
                  |L1.1764|
0006e4  64a5              STR      r5,[r4,#0x48]         ;1528
0006e6  f7fffffe          BL       vPortExitCritical
0006ea  f7fffffe          BL       vPortEnterCritical
0006ee  6c60              LDR      r0,[r4,#0x44]         ;1528
0006f0  2800              CMP      r0,#0                 ;1528
0006f2  dd0f              BLE      |L1.1812|
                  |L1.1780|
0006f4  6920              LDR      r0,[r4,#0x10]         ;1528
0006f6  b168              CBZ      r0,|L1.1812|
0006f8  f1040010          ADD      r0,r4,#0x10           ;1528
0006fc  f7fffffe          BL       xTaskRemoveFromEventList
000700  2800              CMP      r0,#0                 ;1528
000702  bf18              IT       NE                    ;1528
000704  f7fffffe          BLNE     vTaskMissedYield
000708  6c60              LDR      r0,[r4,#0x44]         ;1528
00070a  1e41              SUBS     r1,r0,#1              ;1528
00070c  6461              STR      r1,[r4,#0x44]         ;1528
00070e  6c60              LDR      r0,[r4,#0x44]         ;1528
000710  2800              CMP      r0,#0                 ;1528
000712  dcef              BGT      |L1.1780|
                  |L1.1812|
000714  6465              STR      r5,[r4,#0x44]         ;1528
000716  f7fffffe          BL       vPortExitCritical
00071a  f7fffffe          BL       xTaskResumeAll
00071e  e6eb              B        |L1.1272|
;;;1553   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueReceiveFromISR PROC
;;;1554   
;;;1555   BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
000720  e92d41f0          PUSH     {r4-r8,lr}
;;;1556   {
000724  4616              MOV      r6,r2
000726  460d              MOV      r5,r1
;;;1557   BaseType_t xReturn;
;;;1558   UBaseType_t uxSavedInterruptStatus;
;;;1559   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000728  4604              MOV      r4,r0
;;;1560   
;;;1561   	configASSERT( pxQueue );
;;;1562   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1563   
;;;1564   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1565   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1566   	above the maximum system call priority are kept permanently enabled, even
;;;1567   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1568   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1569   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1570   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1571   	assigned a priority above the configured maximum system call priority.
;;;1572   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1573   	that have been assigned a priority at or (logically) below the maximum
;;;1574   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1575   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1576   	More information (albeit Cortex-M specific) is provided on the following
;;;1577   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1578   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1579   
;;;1580   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00072a  f7fffffe          BL       ulPortSetInterruptMask
00072e  4607              MOV      r7,r0
;;;1581   	{
;;;1582   		/* Cannot block in an ISR, so check there is data available. */
;;;1583   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000730  6ba0              LDR      r0,[r4,#0x38]
000732  2800              CMP      r0,#0
;;;1584   		{
;;;1585   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1586   
;;;1587   			prvCopyDataFromQueue( pxQueue, pvBuffer );
;;;1588   			--( pxQueue->uxMessagesWaiting );
;;;1589   
;;;1590   			/* If the queue is locked the event list will not be modified.
;;;1591   			Instead update the lock count so the task that unlocks the queue
;;;1592   			will know that an ISR has removed data while the queue was
;;;1593   			locked. */
;;;1594   			if( pxQueue->xRxLock == queueUNLOCKED )
;;;1595   			{
;;;1596   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1597   				{
;;;1598   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
;;;1599   					{
;;;1600   						/* The task waiting has a higher priority than us so
;;;1601   						force a context switch. */
;;;1602   						if( pxHigherPriorityTaskWoken != NULL )
;;;1603   						{
;;;1604   							*pxHigherPriorityTaskWoken = pdTRUE;
;;;1605   						}
;;;1606   						else
;;;1607   						{
;;;1608   							mtCOVERAGE_TEST_MARKER();
;;;1609   						}
;;;1610   					}
;;;1611   					else
;;;1612   					{
;;;1613   						mtCOVERAGE_TEST_MARKER();
;;;1614   					}
;;;1615   				}
;;;1616   				else
;;;1617   				{
;;;1618   					mtCOVERAGE_TEST_MARKER();
;;;1619   				}
;;;1620   			}
;;;1621   			else
;;;1622   			{
;;;1623   				/* Increment the lock count so the task that unlocks the queue
;;;1624   				knows that data was removed while it was locked. */
;;;1625   				++( pxQueue->xRxLock );
;;;1626   			}
;;;1627   
;;;1628   			xReturn = pdPASS;
;;;1629   		}
;;;1630   		else
;;;1631   		{
;;;1632   			xReturn = pdFAIL;
000734  bf08              IT       EQ
000736  2400              MOVEQ    r4,#0
000738  d018              BEQ      |L1.1900|
00073a  6c21              LDR      r1,[r4,#0x40]         ;1583
00073c  4628              MOV      r0,r5                 ;1587
00073e  b151              CBZ      r1,|L1.1878|
000740  68e2              LDR      r2,[r4,#0xc]          ;1587
000742  4411              ADD      r1,r1,r2              ;1587
000744  60e1              STR      r1,[r4,#0xc]          ;1587
000746  6862              LDR      r2,[r4,#4]            ;1587
000748  4291              CMP      r1,r2                 ;1587
00074a  bf24              ITT      CS                    ;1587
00074c  6821              LDRCS    r1,[r4,#0]            ;1587
00074e  60e1              STRCS    r1,[r4,#0xc]          ;1587
000750  6c22              LDR      r2,[r4,#0x40]         ;1587
000752  f7fffffe          BL       __aeabi_memcpy
                  |L1.1878|
000756  6ba0              LDR      r0,[r4,#0x38]         ;1588
000758  1e40              SUBS     r0,r0,#1              ;1588
00075a  63a0              STR      r0,[r4,#0x38]         ;1588
00075c  6c60              LDR      r0,[r4,#0x44]         ;1594
00075e  f1b03fff          CMP      r0,#0xffffffff        ;1594
000762  d009              BEQ      |L1.1912|
000764  6c60              LDR      r0,[r4,#0x44]         ;1625
000766  1c40              ADDS     r0,r0,#1              ;1625
000768  6460              STR      r0,[r4,#0x44]         ;1625
                  |L1.1898|
00076a  2401              MOVS     r4,#1                 ;1628
                  |L1.1900|
;;;1633   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1634   		}
;;;1635   	}
;;;1636   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00076c  4638              MOV      r0,r7
00076e  f7fffffe          BL       vPortClearInterruptMask
;;;1637   
;;;1638   	return xReturn;
000772  4620              MOV      r0,r4
;;;1639   }
000774  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1912|
000778  6920              LDR      r0,[r4,#0x10]         ;1596
00077a  2800              CMP      r0,#0                 ;1596
00077c  d0f5              BEQ      |L1.1898|
00077e  f1040010          ADD      r0,r4,#0x10           ;1598
000782  f7fffffe          BL       xTaskRemoveFromEventList
000786  2800              CMP      r0,#0                 ;1598
000788  bf1e              ITTT     NE                    ;1602
00078a  2e00              CMPNE    r6,#0                 ;1602
00078c  2001              MOVNE    r0,#1                 ;1604
00078e  6030              STRNE    r0,[r6,#0]            ;1604
000790  e7eb              B        |L1.1898|
;;;1640   /*-----------------------------------------------------------*/
                          ENDP

                  xQueuePeekFromISR PROC
;;;1641   
;;;1642   BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
000792  e92d41f0          PUSH     {r4-r8,lr}
;;;1643   {
000796  460d              MOV      r5,r1
;;;1644   BaseType_t xReturn;
;;;1645   UBaseType_t uxSavedInterruptStatus;
;;;1646   int8_t *pcOriginalReadPosition;
;;;1647   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000798  4604              MOV      r4,r0
;;;1648   
;;;1649   	configASSERT( pxQueue );
;;;1650   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1651   	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
;;;1652   
;;;1653   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1654   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1655   	above the maximum system call priority are kept permanently enabled, even
;;;1656   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1657   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1658   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1659   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1660   	assigned a priority above the configured maximum system call priority.
;;;1661   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1662   	that have been assigned a priority at or (logically) below the maximum
;;;1663   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1664   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1665   	More information (albeit Cortex-M specific) is provided on the following
;;;1666   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1667   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1668   
;;;1669   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00079a  f7fffffe          BL       ulPortSetInterruptMask
00079e  4607              MOV      r7,r0
;;;1670   	{
;;;1671   		/* Cannot block in an ISR, so check there is data available. */
;;;1672   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
0007a0  6ba0              LDR      r0,[r4,#0x38]
0007a2  2800              CMP      r0,#0
;;;1673   		{
;;;1674   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1675   
;;;1676   			/* Remember the read position so it can be reset as nothing is
;;;1677   			actually being removed from the queue. */
;;;1678   			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
;;;1679   			prvCopyDataFromQueue( pxQueue, pvBuffer );
;;;1680   			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
;;;1681   
;;;1682   			xReturn = pdPASS;
;;;1683   		}
;;;1684   		else
;;;1685   		{
;;;1686   			xReturn = pdFAIL;
0007a4  bf08              IT       EQ
0007a6  2400              MOVEQ    r4,#0
0007a8  d00f              BEQ      |L1.1994|
0007aa  68e6              LDR      r6,[r4,#0xc]          ;1672
0007ac  6c21              LDR      r1,[r4,#0x40]         ;1672
0007ae  4628              MOV      r0,r5                 ;1679
0007b0  b149              CBZ      r1,|L1.1990|
0007b2  4431              ADD      r1,r1,r6              ;1679
0007b4  60e1              STR      r1,[r4,#0xc]          ;1679
0007b6  6862              LDR      r2,[r4,#4]            ;1679
0007b8  4291              CMP      r1,r2                 ;1679
0007ba  bf24              ITT      CS                    ;1679
0007bc  6821              LDRCS    r1,[r4,#0]            ;1679
0007be  60e1              STRCS    r1,[r4,#0xc]          ;1679
0007c0  6c22              LDR      r2,[r4,#0x40]         ;1679
0007c2  f7fffffe          BL       __aeabi_memcpy
                  |L1.1990|
0007c6  60e6              STR      r6,[r4,#0xc]          ;1682
0007c8  2401              MOVS     r4,#1                 ;1682
                  |L1.1994|
;;;1687   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1688   		}
;;;1689   	}
;;;1690   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0007ca  4638              MOV      r0,r7
0007cc  f7fffffe          BL       vPortClearInterruptMask
;;;1691   
;;;1692   	return xReturn;
0007d0  4620              MOV      r0,r4
;;;1693   }
0007d2  e8bd81f0          POP      {r4-r8,pc}
;;;1694   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueMessagesWaiting PROC
;;;1695   
;;;1696   UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
0007d6  b510              PUSH     {r4,lr}
;;;1697   {
0007d8  4604              MOV      r4,r0
;;;1698   UBaseType_t uxReturn;
;;;1699   
;;;1700   	configASSERT( xQueue );
;;;1701   
;;;1702   	taskENTER_CRITICAL();
0007da  f7fffffe          BL       vPortEnterCritical
;;;1703   	{
;;;1704   		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
0007de  6ba4              LDR      r4,[r4,#0x38]
;;;1705   	}
;;;1706   	taskEXIT_CRITICAL();
0007e0  f7fffffe          BL       vPortExitCritical
;;;1707   
;;;1708   	return uxReturn;
0007e4  4620              MOV      r0,r4
;;;1709   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
0007e6  bd10              POP      {r4,pc}
;;;1710   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueSpacesAvailable PROC
;;;1711   
;;;1712   UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
0007e8  b510              PUSH     {r4,lr}
;;;1713   {
;;;1714   UBaseType_t uxReturn;
;;;1715   Queue_t *pxQueue;
;;;1716   
;;;1717   	pxQueue = ( Queue_t * ) xQueue;
0007ea  4604              MOV      r4,r0
;;;1718   	configASSERT( pxQueue );
;;;1719   
;;;1720   	taskENTER_CRITICAL();
0007ec  f7fffffe          BL       vPortEnterCritical
;;;1721   	{
;;;1722   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
0007f0  6ba1              LDR      r1,[r4,#0x38]
0007f2  6be0              LDR      r0,[r4,#0x3c]
0007f4  1a44              SUBS     r4,r0,r1
;;;1723   	}
;;;1724   	taskEXIT_CRITICAL();
0007f6  f7fffffe          BL       vPortExitCritical
;;;1725   
;;;1726   	return uxReturn;
0007fa  4620              MOV      r0,r4
;;;1727   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
0007fc  bd10              POP      {r4,pc}
;;;1728   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueMessagesWaitingFromISR PROC
;;;1729   
;;;1730   UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
0007fe  6b80              LDR      r0,[r0,#0x38]
;;;1731   {
;;;1732   UBaseType_t uxReturn;
;;;1733   
;;;1734   	configASSERT( xQueue );
;;;1735   
;;;1736   	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
;;;1737   
;;;1738   	return uxReturn;
;;;1739   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000800  4770              BX       lr
;;;1740   /*-----------------------------------------------------------*/
                          ENDP

                  vQueueDelete PROC
;;;1741   
;;;1742   void vQueueDelete( QueueHandle_t xQueue )
000802  f7ffbffe          B.W      vPortFree
;;;1743   {
;;;1744   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1745   
;;;1746   	configASSERT( pxQueue );
;;;1747   
;;;1748   	traceQUEUE_DELETE( pxQueue );
;;;1749   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1750   	{
;;;1751   		vQueueUnregisterQueue( pxQueue );
;;;1752   	}
;;;1753   	#endif
;;;1754   	vPortFree( pxQueue );
;;;1755   }
;;;1756   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueIsQueueEmptyFromISR PROC
;;;2015   
;;;2016   BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
000806  6b80              LDR      r0,[r0,#0x38]
;;;2017   {
;;;2018   BaseType_t xReturn;
;;;2019   
;;;2020   	configASSERT( xQueue );
;;;2021   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
000808  2800              CMP      r0,#0
;;;2022   	{
;;;2023   		xReturn = pdTRUE;
00080a  bf0c              ITE      EQ
00080c  2001              MOVEQ    r0,#1
;;;2024   	}
;;;2025   	else
;;;2026   	{
;;;2027   		xReturn = pdFALSE;
00080e  2000              MOVNE    r0,#0
;;;2028   	}
;;;2029   
;;;2030   	return xReturn;
;;;2031   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000810  4770              BX       lr
;;;2032   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueIsQueueFullFromISR PROC
;;;2054   
;;;2055   BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
000812  6b81              LDR      r1,[r0,#0x38]
;;;2056   {
;;;2057   BaseType_t xReturn;
;;;2058   
;;;2059   	configASSERT( xQueue );
;;;2060   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
000814  6bc0              LDR      r0,[r0,#0x3c]
000816  4281              CMP      r1,r0
;;;2061   	{
;;;2062   		xReturn = pdTRUE;
000818  bf0c              ITE      EQ
00081a  2001              MOVEQ    r0,#1
;;;2063   	}
;;;2064   	else
;;;2065   	{
;;;2066   		xReturn = pdFALSE;
00081c  2000              MOVNE    r0,#0
;;;2067   	}
;;;2068   
;;;2069   	return xReturn;
;;;2070   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00081e  4770              BX       lr
;;;2071   /*-----------------------------------------------------------*/
                          ENDP

                  vQueueWaitForMessageRestricted PROC
;;;2405   
;;;2406   	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
000820  b570              PUSH     {r4-r6,lr}
;;;2407   	{
000822  460d              MOV      r5,r1
;;;2408   	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000824  4604              MOV      r4,r0
;;;2409   
;;;2410   		/* This function should not be called by application code hence the
;;;2411   		'Restricted' in its name.  It is not part of the public API.  It is
;;;2412   		designed for use by kernel code, and has special calling requirements.
;;;2413   		It can result in vListInsert() being called on a list that can only
;;;2414   		possibly ever have one item in it, so the list will be fast, but even
;;;2415   		so it should be called with the scheduler locked and not from a critical
;;;2416   		section. */
;;;2417   
;;;2418   		/* Only do anything if there are no messages in the queue.  This function
;;;2419   		will not actually cause the task to block, just place it on a blocked
;;;2420   		list.  It will not block until the scheduler is unlocked - at which
;;;2421   		time a yield will be performed.  If an item is added to the queue while
;;;2422   		the queue is locked, and the calling task blocks on the queue, then the
;;;2423   		calling task will be immediately unblocked when the queue is unlocked. */
;;;2424   		prvLockQueue( pxQueue );
000826  f7fffffe          BL       vPortEnterCritical
00082a  6c60              LDR      r0,[r4,#0x44]
00082c  f1b03fff          CMP      r0,#0xffffffff
000830  f04f0000          MOV      r0,#0
000834  bf08              IT       EQ
000836  6460              STREQ    r0,[r4,#0x44]
000838  6ca1              LDR      r1,[r4,#0x48]
00083a  f1b13fff          CMP      r1,#0xffffffff
00083e  bf08              IT       EQ
000840  64a0              STREQ    r0,[r4,#0x48]
000842  f7fffffe          BL       vPortExitCritical
;;;2425   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
000846  6ba0              LDR      r0,[r4,#0x38]
000848  b920              CBNZ     r0,|L1.2132|
;;;2426   		{
;;;2427   			/* There is nothing in the queue, block for the specified period. */
;;;2428   			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
00084a  4629              MOV      r1,r5
00084c  f1040024          ADD      r0,r4,#0x24
000850  f7fffffe          BL       vTaskPlaceOnEventListRestricted
                  |L1.2132|
;;;2429   		}
;;;2430   		else
;;;2431   		{
;;;2432   			mtCOVERAGE_TEST_MARKER();
;;;2433   		}
;;;2434   		prvUnlockQueue( pxQueue );
000854  4620              MOV      r0,r4
000856  e8bd4070          POP      {r4-r6,lr}
00085a  f7ffbffe          B.W      prvUnlockQueue
;;;2435   	}
;;;2436   
                          ENDP

                  prvUnlockQueue PROC
;;;1879   
;;;1880   static void prvUnlockQueue( Queue_t * const pxQueue )
00085e  b570              PUSH     {r4-r6,lr}
;;;1881   {
000860  4604              MOV      r4,r0
;;;1882   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;1883   
;;;1884   	/* The lock counts contains the number of extra data items placed or
;;;1885   	removed from the queue while the queue was locked.  When a queue is
;;;1886   	locked items can be added or removed, but the event lists cannot be
;;;1887   	updated. */
;;;1888   	taskENTER_CRITICAL();
000862  f7fffffe          BL       vPortEnterCritical
;;;1889   	{
;;;1890   		/* See if data was added to the queue while it was locked. */
;;;1891   		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
000866  6ca0              LDR      r0,[r4,#0x48]
000868  2800              CMP      r0,#0
00086a  dd0f              BLE      |L1.2188|
                  |L1.2156|
;;;1892   		{
;;;1893   			/* Data was posted while the queue was locked.  Are any tasks
;;;1894   			blocked waiting for data to become available? */
;;;1895   			#if ( configUSE_QUEUE_SETS == 1 )
;;;1896   			{
;;;1897   				if( pxQueue->pxQueueSetContainer != NULL )
;;;1898   				{
;;;1899   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
;;;1900   					{
;;;1901   						/* The queue is a member of a queue set, and posting to
;;;1902   						the queue set caused a higher priority task to unblock.
;;;1903   						A context switch is required. */
;;;1904   						vTaskMissedYield();
;;;1905   					}
;;;1906   					else
;;;1907   					{
;;;1908   						mtCOVERAGE_TEST_MARKER();
;;;1909   					}
;;;1910   				}
;;;1911   				else
;;;1912   				{
;;;1913   					/* Tasks that are removed from the event list will get added to
;;;1914   					the pending ready list as the scheduler is still suspended. */
;;;1915   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1916   					{
;;;1917   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1918   						{
;;;1919   							/* The task waiting has a higher priority so record that a
;;;1920   							context	switch is required. */
;;;1921   							vTaskMissedYield();
;;;1922   						}
;;;1923   						else
;;;1924   						{
;;;1925   							mtCOVERAGE_TEST_MARKER();
;;;1926   						}
;;;1927   					}
;;;1928   					else
;;;1929   					{
;;;1930   						break;
;;;1931   					}
;;;1932   				}
;;;1933   			}
;;;1934   			#else /* configUSE_QUEUE_SETS */
;;;1935   			{
;;;1936   				/* Tasks that are removed from the event list will get added to
;;;1937   				the pending ready list as the scheduler is still suspended. */
;;;1938   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00086c  6a60              LDR      r0,[r4,#0x24]
00086e  b168              CBZ      r0,|L1.2188|
;;;1939   				{
;;;1940   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000870  f1040024          ADD      r0,r4,#0x24
000874  f7fffffe          BL       xTaskRemoveFromEventList
000878  2800              CMP      r0,#0
;;;1941   					{
;;;1942   						/* The task waiting has a higher priority so record that a
;;;1943   						context	switch is required. */
;;;1944   						vTaskMissedYield();
00087a  bf18              IT       NE
00087c  f7fffffe          BLNE     vTaskMissedYield
;;;1945   					}
;;;1946   					else
;;;1947   					{
;;;1948   						mtCOVERAGE_TEST_MARKER();
;;;1949   					}
;;;1950   				}
;;;1951   				else
;;;1952   				{
;;;1953   					break;
;;;1954   				}
;;;1955   			}
;;;1956   			#endif /* configUSE_QUEUE_SETS */
;;;1957   
;;;1958   			--( pxQueue->xTxLock );
000880  6ca0              LDR      r0,[r4,#0x48]
000882  1e40              SUBS     r0,r0,#1
000884  64a0              STR      r0,[r4,#0x48]
000886  6ca0              LDR      r0,[r4,#0x48]         ;1891
000888  2800              CMP      r0,#0                 ;1891
00088a  dcef              BGT      |L1.2156|
                  |L1.2188|
;;;1959   		}
;;;1960   
;;;1961   		pxQueue->xTxLock = queueUNLOCKED;
00088c  f04f35ff          MOV      r5,#0xffffffff
000890  64a5              STR      r5,[r4,#0x48]
;;;1962   	}
;;;1963   	taskEXIT_CRITICAL();
000892  f7fffffe          BL       vPortExitCritical
;;;1964   
;;;1965   	/* Do the same for the Rx lock. */
;;;1966   	taskENTER_CRITICAL();
000896  f7fffffe          BL       vPortEnterCritical
;;;1967   	{
;;;1968   		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
00089a  6c60              LDR      r0,[r4,#0x44]
00089c  2800              CMP      r0,#0
00089e  dd0f              BLE      |L1.2240|
                  |L1.2208|
;;;1969   		{
;;;1970   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
0008a0  6920              LDR      r0,[r4,#0x10]
0008a2  b168              CBZ      r0,|L1.2240|
;;;1971   			{
;;;1972   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
0008a4  f1040010          ADD      r0,r4,#0x10
0008a8  f7fffffe          BL       xTaskRemoveFromEventList
0008ac  2800              CMP      r0,#0
;;;1973   				{
;;;1974   					vTaskMissedYield();
0008ae  bf18              IT       NE
0008b0  f7fffffe          BLNE     vTaskMissedYield
;;;1975   				}
;;;1976   				else
;;;1977   				{
;;;1978   					mtCOVERAGE_TEST_MARKER();
;;;1979   				}
;;;1980   
;;;1981   				--( pxQueue->xRxLock );
0008b4  6c60              LDR      r0,[r4,#0x44]
0008b6  1e40              SUBS     r0,r0,#1
0008b8  6460              STR      r0,[r4,#0x44]
0008ba  6c60              LDR      r0,[r4,#0x44]         ;1968
0008bc  2800              CMP      r0,#0                 ;1968
0008be  dcef              BGT      |L1.2208|
                  |L1.2240|
;;;1982   			}
;;;1983   			else
;;;1984   			{
;;;1985   				break;
;;;1986   			}
;;;1987   		}
;;;1988   
;;;1989   		pxQueue->xRxLock = queueUNLOCKED;
0008c0  6465              STR      r5,[r4,#0x44]
;;;1990   	}
;;;1991   	taskEXIT_CRITICAL();
0008c2  e8bd4070          POP      {r4-r6,lr}
0008c6  f7ffbffe          B.W      vPortExitCritical
;;;1992   }
;;;1993   /*-----------------------------------------------------------*/
                          ENDP

