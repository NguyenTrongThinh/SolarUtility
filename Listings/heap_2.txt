; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\heap_2.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\heap_2.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I.\Driver -I.\Application -I.\System\FreeRTOS\include -I.\System\FreeRTOS\portable\MemMang -I.\System\FreeRTOS\portable\RVDS\ARM_CM3 -I.\System\Libraries\CMSIS\CM3\CoreSupport -I.\System\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I.\System\Libraries\STM32F10x_StdPeriph_Driver\inc -ID:\ARM\SolarUtility\RTE -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=516 -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\objects\heap_2.crf System\FreeRTOS\portable\MemMang\heap_2.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  pvPortMalloc PROC
;;;148    
;;;149    void *pvPortMalloc( size_t xWantedSize )
000000  b570              PUSH     {r4-r6,lr}
;;;150    {
000002  4606              MOV      r6,r0
;;;151    BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
;;;152    static BaseType_t xHeapHasBeenInitialised = pdFALSE;
;;;153    void *pvReturn = NULL;
000004  2400              MOVS     r4,#0
;;;154    
;;;155    	vTaskSuspendAll();
000006  f7fffffe          BL       vTaskSuspendAll
;;;156    	{
;;;157    		/* If this is the first call to malloc then the heap will require
;;;158    		initialisation to setup the list of free blocks. */
;;;159    		if( xHeapHasBeenInitialised == pdFALSE )
00000a  483c              LDR      r0,|L1.252|
00000c  f1000308          ADD      r3,r0,#8
000010  6841              LDR      r1,[r0,#4]  ; xHeapHasBeenInitialised
000012  f1000510          ADD      r5,r0,#0x10
000016  b969              CBNZ     r1,|L1.52|
000018  4939              LDR      r1,|L1.256|
00001a  46a4              MOV      r12,r4
00001c  f0210107          BIC      r1,r1,#7
000020  e9c31c00          STRD     r1,r12,[r3,#0]
000024  f24272f8          MOV      r2,#0x27f8
000028  e9c5c200          STRD     r12,r2,[r5,#0]
00002c  e9c15200          STRD     r5,r2,[r1,#0]
;;;160    		{
;;;161    			prvHeapInit();
;;;162    			xHeapHasBeenInitialised = pdTRUE;
000030  2101              MOVS     r1,#1
000032  6041              STR      r1,[r0,#4]  ; xHeapHasBeenInitialised
                  |L1.52|
;;;163    		}
;;;164    
;;;165    		/* The wanted size is increased so it can contain a BlockLink_t
;;;166    		structure in addition to the requested amount of bytes. */
;;;167    		if( xWantedSize > 0 )
000034  2e00              CMP      r6,#0
000036  d03e              BEQ      |L1.182|
;;;168    		{
;;;169    			xWantedSize += heapSTRUCT_SIZE;
000038  f1060208          ADD      r2,r6,#8
;;;170    
;;;171    			/* Ensure that blocks are always aligned to the required number of bytes. */
;;;172    			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
00003c  f0120f07          TST      r2,#7
000040  d004              BEQ      |L1.76|
;;;173    			{
;;;174    				/* Byte alignment required. */
;;;175    				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
000042  f0020107          AND      r1,r2,#7
000046  f1c10108          RSB      r1,r1,#8
00004a  440a              ADD      r2,r2,r1
                  |L1.76|
;;;176    			}
;;;177    		}
;;;178    
;;;179    		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
00004c  1e51              SUBS     r1,r2,#1
00004e  f2427cf7          MOV      r12,#0x27f7
000052  4561              CMP      r1,r12
;;;180    		{
;;;181    			/* Blocks are stored in byte order - traverse the list from the start
;;;182    			(smallest) block until one of adequate size is found. */
;;;183    			pxPreviousBlock = &xStart;
000054  bf3c              ITT      CC
000056  f8dfc0ac          LDRCC    r12,|L1.260|
;;;184    			pxBlock = xStart.pxNextFreeBlock;
00005a  6819              LDRCC    r1,[r3,#0]  ; xStart
00005c  d22b              BCS      |L1.182|
                  |L1.94|
;;;185    			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
00005e  684b              LDR      r3,[r1,#4]
000060  4293              CMP      r3,r2
000062  d205              BCS      |L1.112|
000064  680b              LDR      r3,[r1,#0]
000066  2b00              CMP      r3,#0
;;;186    			{
;;;187    				pxPreviousBlock = pxBlock;
000068  bf1c              ITT      NE
00006a  468c              MOVNE    r12,r1
00006c  4619              MOVNE    r1,r3
00006e  d1f6              BNE      |L1.94|
                  |L1.112|
;;;188    				pxBlock = pxBlock->pxNextFreeBlock;
;;;189    			}
;;;190    
;;;191    			/* If we found the end marker then a block of adequate size was not found. */
;;;192    			if( pxBlock != &xEnd )
000070  42a9              CMP      r1,r5
000072  d020              BEQ      |L1.182|
;;;193    			{
;;;194    				/* Return the memory space - jumping over the BlockLink_t structure
;;;195    				at its start. */
;;;196    				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
000074  f8dc3000          LDR      r3,[r12,#0]
000078  f1030408          ADD      r4,r3,#8
;;;197    
;;;198    				/* This block is being returned for use so must be taken out of the
;;;199    				list of free blocks. */
;;;200    				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
00007c  680b              LDR      r3,[r1,#0]
;;;201    
;;;202    				/* If the block is larger than required it can be split into two. */
;;;203    				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
00007e  f8cc3000          STR      r3,[r12,#0]
000082  684b              LDR      r3,[r1,#4]
000084  1a9b              SUBS     r3,r3,r2
000086  2b10              CMP      r3,#0x10
000088  d911              BLS      |L1.174|
;;;204    				{
;;;205    					/* This block is to be split into two.  Create a new block
;;;206    					following the number of bytes requested. The void cast is
;;;207    					used to prevent byte alignment warnings from the compiler. */
;;;208    					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
00008a  eb010c02          ADD      r12,r1,r2
;;;209    
;;;210    					/* Calculate the sizes of two blocks split from the single
;;;211    					block. */
;;;212    					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
;;;213    					pxBlock->xBlockSize = xWantedSize;
;;;214    
;;;215    					/* Insert the new block into the list of free blocks. */
;;;216    					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
00008e  4d1d              LDR      r5,|L1.260|
000090  f8cc3004          STR      r3,[r12,#4]           ;213
000094  604a              STR      r2,[r1,#4]
000096  f8dc3004          LDR      r3,[r12,#4]
                  |L1.154|
00009a  682a              LDR      r2,[r5,#0]
00009c  6856              LDR      r6,[r2,#4]
00009e  429e              CMP      r6,r3
0000a0  bf38              IT       CC
0000a2  4615              MOVCC    r5,r2
0000a4  d3f9              BCC      |L1.154|
0000a6  f8cc2000          STR      r2,[r12,#0]
0000aa  f8c5c000          STR      r12,[r5,#0]
                  |L1.174|
;;;217    				}
;;;218    
;;;219    				xFreeBytesRemaining -= pxBlock->xBlockSize;
0000ae  6849              LDR      r1,[r1,#4]
0000b0  6802              LDR      r2,[r0,#0]  ; xFreeBytesRemaining
0000b2  1a51              SUBS     r1,r2,r1
0000b4  6001              STR      r1,[r0,#0]  ; xFreeBytesRemaining
                  |L1.182|
;;;220    			}
;;;221    		}
;;;222    
;;;223    		traceMALLOC( pvReturn, xWantedSize );
;;;224    	}
;;;225    	( void ) xTaskResumeAll();
0000b6  f7fffffe          BL       xTaskResumeAll
;;;226    
;;;227    	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
;;;228    	{
;;;229    		if( pvReturn == NULL )
;;;230    		{
;;;231    			extern void vApplicationMallocFailedHook( void );
;;;232    			vApplicationMallocFailedHook();
;;;233    		}
;;;234    	}
;;;235    	#endif
;;;236    
;;;237    	return pvReturn;
0000ba  4620              MOV      r0,r4
;;;238    }
0000bc  bd70              POP      {r4-r6,pc}
;;;239    /*-----------------------------------------------------------*/
                          ENDP

                  vPortFree PROC
;;;240    
;;;241    void vPortFree( void *pv )
0000be  2800              CMP      r0,#0
;;;242    {
;;;243    uint8_t *puc = ( uint8_t * ) pv;
;;;244    BlockLink_t *pxLink;
;;;245    
;;;246    	if( pv != NULL )
;;;247    	{
;;;248    		/* The memory being freed will have an BlockLink_t structure immediately
;;;249    		before it. */
;;;250    		puc -= heapSTRUCT_SIZE;
;;;251    
;;;252    		/* This unexpected casting is to keep some compilers from issuing
;;;253    		byte alignment warnings. */
;;;254    		pxLink = ( void * ) puc;
;;;255    
;;;256    		vTaskSuspendAll();
;;;257    		{
;;;258    			/* Add this block to the list of free blocks. */
;;;259    			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
;;;260    			xFreeBytesRemaining += pxLink->xBlockSize;
;;;261    			traceFREE( pv, pxLink->xBlockSize );
;;;262    		}
;;;263    		( void ) xTaskResumeAll();
;;;264    	}
;;;265    }
0000c0  bf08              IT       EQ
0000c2  4770              BXEQ     lr
0000c4  b510              PUSH     {r4,lr}               ;242
0000c6  f1a00408          SUB      r4,r0,#8              ;250
0000ca  f7fffffe          BL       vTaskSuspendAll
0000ce  480d              LDR      r0,|L1.260|
0000d0  6861              LDR      r1,[r4,#4]            ;259
                  |L1.210|
0000d2  6802              LDR      r2,[r0,#0]            ;259
0000d4  6853              LDR      r3,[r2,#4]            ;259
0000d6  428b              CMP      r3,r1                 ;259
0000d8  bf38              IT       CC                    ;259
0000da  4610              MOVCC    r0,r2                 ;259
0000dc  d3f9              BCC      |L1.210|
0000de  6022              STR      r2,[r4,#0]            ;259
0000e0  6004              STR      r4,[r0,#0]            ;260
0000e2  4806              LDR      r0,|L1.252|
0000e4  6861              LDR      r1,[r4,#4]            ;260
0000e6  6802              LDR      r2,[r0,#0]            ;260  ; xFreeBytesRemaining
0000e8  4411              ADD      r1,r1,r2              ;260
0000ea  6001              STR      r1,[r0,#0]            ;263  ; xFreeBytesRemaining
0000ec  e8bd4010          POP      {r4,lr}               ;263
0000f0  f7ffbffe          B.W      xTaskResumeAll
;;;266    /*-----------------------------------------------------------*/
                          ENDP

                  xPortGetFreeHeapSize PROC
;;;267    
;;;268    size_t xPortGetFreeHeapSize( void )
0000f4  4801              LDR      r0,|L1.252|
;;;269    {
;;;270    	return xFreeBytesRemaining;
0000f6  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
;;;271    }
0000f8  4770              BX       lr
;;;272    /*-----------------------------------------------------------*/
                          ENDP

                  vPortInitialiseBlocks PROC
;;;273    
;;;274    void vPortInitialiseBlocks( void )
0000fa  4770              BX       lr
;;;275    {
;;;276    	/* This just exists to keep the linker quiet. */
;;;277    }
;;;278    /*-----------------------------------------------------------*/
                          ENDP

                  |L1.252|
                          DCD      ||.data||
                  |L1.256|
                          DCD      ||.bss||+0x8
                  |L1.260|
                          DCD      ||.data||+0x8

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ucHeap
                          %        10240

                          AREA ||.data||, DATA, ALIGN=2

                  xFreeBytesRemaining
                          DCD      0x000027f8
                  xHeapHasBeenInitialised
                          DCD      0x00000000
                  xStart
                          %        8
                  xEnd
                          %        8
