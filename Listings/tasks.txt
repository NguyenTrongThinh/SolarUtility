; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\tasks.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\tasks.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I.\Driver -I.\Application -I.\System\FreeRTOS\include -I.\System\FreeRTOS\portable\MemMang -I.\System\FreeRTOS\portable\RVDS\ARM_CM3 -I.\System\Libraries\CMSIS\CM3\CoreSupport -I.\System\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I.\System\Libraries\STM32F10x_StdPeriph_Driver\inc -ID:\ARM\SolarUtility\RTE -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=516 -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\objects\tasks.crf System\FreeRTOS\tasks.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  xTaskGenericCreate PROC
;;;550    
;;;551    BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;552    {
000004  469a              MOV      r10,r3
000006  e9dd850b          LDRD     r8,r5,[sp,#0x2c]
00000a  9f0a              LDR      r7,[sp,#0x28]
00000c  4691              MOV      r9,r2
00000e  460e              MOV      r6,r1
000010  4683              MOV      r11,r0
000012  b925              CBNZ     r5,|L1.30|
000014  ea4f0089          LSL      r0,r9,#2
000018  f7fffffe          BL       pvPortMalloc
00001c  4605              MOV      r5,r0
                  |L1.30|
00001e  2d00              CMP      r5,#0
000020  d04f              BEQ      |L1.194|
000022  2054              MOVS     r0,#0x54
000024  f7fffffe          BL       pvPortMalloc
000028  0004              MOVS     r4,r0
00002a  d047              BEQ      |L1.188|
;;;553    BaseType_t xReturn;
;;;554    TCB_t * pxNewTCB;
;;;555    StackType_t *pxTopOfStack;
;;;556    
;;;557    	configASSERT( pxTaskCode );
;;;558    	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );
;;;559    
;;;560    	/* Allocate the memory required by the TCB and stack for the new task,
;;;561    	checking that the allocation was successful. */
;;;562    	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
;;;563    
;;;564    	if( pxNewTCB != NULL )
;;;565    	{
;;;566    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;567    			/* Should the task be created in privileged mode? */
;;;568    			BaseType_t xRunPrivileged;
;;;569    			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;570    			{
;;;571    				xRunPrivileged = pdTRUE;
;;;572    			}
;;;573    			else
;;;574    			{
;;;575    				xRunPrivileged = pdFALSE;
;;;576    			}
;;;577    			uxPriority &= ~portPRIVILEGE_BIT;
;;;578    
;;;579    			if( puxStackBuffer != NULL )
;;;580    			{
;;;581    				/* The application provided its own stack.  Note this so no
;;;582    				attempt is made to delete the stack should that task be
;;;583    				deleted. */
;;;584    				pxNewTCB->xUsingStaticallyAllocatedStack = pdTRUE;
;;;585    			}
;;;586    			else
;;;587    			{
;;;588    				/* The stack was allocated dynamically.  Note this so it can be
;;;589    				deleted again if the task is deleted. */
;;;590    				pxNewTCB->xUsingStaticallyAllocatedStack = pdFALSE;
;;;591    			}
;;;592    		#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;593    
;;;594    		/* Calculate the top of stack address.  This depends on whether the
;;;595    		stack grows from high memory to low (as per the 80x86) or vice versa.
;;;596    		portSTACK_GROWTH is used to make the result positive or negative as
;;;597    		required by the port. */
;;;598    		#if( portSTACK_GROWTH < 0 )
;;;599    		{
;;;600    			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
00002c  f06f0003          MVN      r0,#3
000030  eb000089          ADD      r0,r0,r9,LSL #2
000034  4428              ADD      r0,r0,r5
;;;601    			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
000036  f0200907          BIC      r9,r0,#7
;;;602    
;;;603    			/* Check the alignment of the calculated top of stack is correct. */
;;;604    			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;605    		}
;;;606    		#else /* portSTACK_GROWTH */
;;;607    		{
;;;608    			pxTopOfStack = pxNewTCB->pxStack;
;;;609    
;;;610    			/* Check the alignment of the stack buffer is correct. */
;;;611    			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;612    
;;;613    			/* If we want to use stack checking on architectures that use
;;;614    			a positive stack growth direction then we also need to store the
;;;615    			other extreme of the stack space. */
;;;616    			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
;;;617    		}
;;;618    		#endif /* portSTACK_GROWTH */
;;;619    
;;;620    		/* Setup the newly allocated TCB with the initial state of the task. */
;;;621    		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
00003a  6325              STR      r5,[r4,#0x30]
00003c  463d              MOV      r5,r7
00003e  2000              MOVS     r0,#0
                  |L1.64|
000040  1821              ADDS     r1,r4,r0
000042  5c32              LDRB     r2,[r6,r0]
000044  f8812034          STRB     r2,[r1,#0x34]
000048  5c31              LDRB     r1,[r6,r0]
00004a  2900              CMP      r1,#0
00004c  bf1c              ITT      NE
00004e  1c40              ADDNE    r0,r0,#1
000050  2810              CMPNE    r0,#0x10
000052  d3f5              BCC      |L1.64|
000054  2600              MOVS     r6,#0
000056  f8846043          STRB     r6,[r4,#0x43]
00005a  2d05              CMP      r5,#5
00005c  bf28              IT       CS
00005e  2504              MOVCS    r5,#4
000060  1d20              ADDS     r0,r4,#4
000062  62e5              STR      r5,[r4,#0x2c]
000064  e9c45611          STRD     r5,r6,[r4,#0x44]
000068  f7fffffe          BL       vListInitialiseItem
00006c  f1040018          ADD      r0,r4,#0x18
000070  f7fffffe          BL       vListInitialiseItem
000074  6124              STR      r4,[r4,#0x10]
000076  f1c50105          RSB      r1,r5,#5
00007a  6264              STR      r4,[r4,#0x24]
00007c  61a1              STR      r1,[r4,#0x18]
00007e  64e6              STR      r6,[r4,#0x4c]
000080  f8846050          STRB     r6,[r4,#0x50]
;;;622    
;;;623    		/* Initialize the TCB stack to look as if the task was already running,
;;;624    		but had been interrupted by the scheduler.  The return address is set
;;;625    		to the start of the task function. Once the stack has been initialised
;;;626    		the	top of stack variable is updated. */
;;;627    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;628    		{
;;;629    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;630    		}
;;;631    		#else /* portUSING_MPU_WRAPPERS */
;;;632    		{
;;;633    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
000084  4652              MOV      r2,r10
000086  4659              MOV      r1,r11
000088  4648              MOV      r0,r9
00008a  f7fffffe          BL       pxPortInitialiseStack
;;;634    		}
;;;635    		#endif /* portUSING_MPU_WRAPPERS */
;;;636    
;;;637    		if( ( void * ) pxCreatedTask != NULL )
00008e  6020              STR      r0,[r4,#0]
000090  f1b80f00          CMP      r8,#0
;;;638    		{
;;;639    			/* Pass the TCB out - in an anonymous way.  The calling function/
;;;640    			task can use this as a handle to delete the task later if
;;;641    			required.*/
;;;642    			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
000094  bf18              IT       NE
000096  f8c84000          STRNE    r4,[r8,#0]
;;;643    		}
;;;644    		else
;;;645    		{
;;;646    			mtCOVERAGE_TEST_MARKER();
;;;647    		}
;;;648    
;;;649    		/* Ensure interrupts don't access the task lists while they are being
;;;650    		updated. */
;;;651    		taskENTER_CRITICAL();
00009a  f7fffffe          BL       vPortEnterCritical
;;;652    		{
;;;653    			uxCurrentNumberOfTasks++;
00009e  f8df8404          LDR      r8,|L1.1188|
0000a2  f8d80008          LDR      r0,[r8,#8]  ; uxCurrentNumberOfTasks
0000a6  1c40              ADDS     r0,r0,#1
0000a8  f8c80008          STR      r0,[r8,#8]  ; uxCurrentNumberOfTasks
;;;654    			if( pxCurrentTCB == NULL )
0000ac  f8d80000          LDR      r0,[r8,#0]  ; pxCurrentTCB
0000b0  4efd              LDR      r6,|L1.1192|
0000b2  b148              CBZ      r0,|L1.200|
;;;655    			{
;;;656    				/* There are no other tasks, or all the other tasks are in
;;;657    				the suspended state - make this the current task. */
;;;658    				pxCurrentTCB =  pxNewTCB;
;;;659    
;;;660    				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
;;;661    				{
;;;662    					/* This is the first task to be created so do the preliminary
;;;663    					initialisation required.  We will not recover if this call
;;;664    					fails, but we will report the failure. */
;;;665    					prvInitialiseTaskLists();
;;;666    				}
;;;667    				else
;;;668    				{
;;;669    					mtCOVERAGE_TEST_MARKER();
;;;670    				}
;;;671    			}
;;;672    			else
;;;673    			{
;;;674    				/* If the scheduler is not already running, make this task the
;;;675    				current task if it is the highest priority task to be created
;;;676    				so far. */
;;;677    				if( xSchedulerRunning == pdFALSE )
0000b4  f8d80014          LDR      r0,[r8,#0x14]  ; xSchedulerRunning
0000b8  b368              CBZ      r0,|L1.278|
0000ba  e033              B        |L1.292|
                  |L1.188|
0000bc  4628              MOV      r0,r5
0000be  f7fffffe          BL       vPortFree
                  |L1.194|
;;;678    				{
;;;679    					if( pxCurrentTCB->uxPriority <= uxPriority )
;;;680    					{
;;;681    						pxCurrentTCB = pxNewTCB;
;;;682    					}
;;;683    					else
;;;684    					{
;;;685    						mtCOVERAGE_TEST_MARKER();
;;;686    					}
;;;687    				}
;;;688    				else
;;;689    				{
;;;690    					mtCOVERAGE_TEST_MARKER();
;;;691    				}
;;;692    			}
;;;693    
;;;694    			uxTaskNumber++;
;;;695    
;;;696    			#if ( configUSE_TRACE_FACILITY == 1 )
;;;697    			{
;;;698    				/* Add a counter into the TCB for tracing only. */
;;;699    				pxNewTCB->uxTCBNumber = uxTaskNumber;
;;;700    			}
;;;701    			#endif /* configUSE_TRACE_FACILITY */
;;;702    			traceTASK_CREATE( pxNewTCB );
;;;703    
;;;704    			prvAddTaskToReadyList( pxNewTCB );
;;;705    
;;;706    			xReturn = pdPASS;
;;;707    			portSETUP_TCB( pxNewTCB );
;;;708    		}
;;;709    		taskEXIT_CRITICAL();
;;;710    	}
;;;711    	else
;;;712    	{
;;;713    		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
0000c2  f04f34ff          MOV      r4,#0xffffffff
0000c6  e04e              B        |L1.358|
                  |L1.200|
0000c8  f8c84000          STR      r4,[r8,#0]            ;658  ; pxCurrentTCB
0000cc  f8d80008          LDR      r0,[r8,#8]            ;660  ; uxCurrentNumberOfTasks
0000d0  2801              CMP      r0,#1                 ;660
0000d2  bf08              IT       EQ                    ;660
0000d4  2500              MOVEQ    r5,#0                 ;660
0000d6  d125              BNE      |L1.292|
                  |L1.216|
0000d8  eb050085          ADD      r0,r5,r5,LSL #2       ;660
0000dc  eb060080          ADD      r0,r6,r0,LSL #2       ;660
0000e0  f7fffffe          BL       vListInitialise
0000e4  1c6d              ADDS     r5,r5,#1              ;660
0000e6  2d05              CMP      r5,#5                 ;660
0000e8  d3f6              BCC      |L1.216|
0000ea  48f0              LDR      r0,|L1.1196|
0000ec  f7fffffe          BL       vListInitialise
0000f0  48ef              LDR      r0,|L1.1200|
0000f2  f7fffffe          BL       vListInitialise
0000f6  48ef              LDR      r0,|L1.1204|
0000f8  f7fffffe          BL       vListInitialise
0000fc  48ee              LDR      r0,|L1.1208|
0000fe  f7fffffe          BL       vListInitialise
000102  48ee              LDR      r0,|L1.1212|
000104  f7fffffe          BL       vListInitialise
000108  48e8              LDR      r0,|L1.1196|
00010a  f8c80030          STR      r0,[r8,#0x30]         ;660  ; pxDelayedTaskList
00010e  3014              ADDS     r0,r0,#0x14           ;660
000110  f8c80034          STR      r0,[r8,#0x34]         ;660  ; pxOverflowDelayedTaskList
000114  e006              B        |L1.292|
                  |L1.278|
000116  f8d80000          LDR      r0,[r8,#0]            ;679  ; pxCurrentTCB
00011a  6ac0              LDR      r0,[r0,#0x2c]         ;679
00011c  42b8              CMP      r0,r7                 ;679
00011e  bf98              IT       LS                    ;681
000120  f8c84000          STRLS    r4,[r8,#0]            ;681  ; pxCurrentTCB
                  |L1.292|
000124  f8d80024          LDR      r0,[r8,#0x24]         ;694  ; uxTaskNumber
000128  2101              MOVS     r1,#1                 ;704
00012a  1c40              ADDS     r0,r0,#1              ;694
00012c  f8c80024          STR      r0,[r8,#0x24]         ;704  ; uxTaskNumber
000130  6ae0              LDR      r0,[r4,#0x2c]         ;704
000132  f8d82010          LDR      r2,[r8,#0x10]         ;704  ; uxTopReadyPriority
000136  4081              LSLS     r1,r1,r0              ;704
000138  4311              ORRS     r1,r1,r2              ;704
00013a  f8c81010          STR      r1,[r8,#0x10]         ;704  ; uxTopReadyPriority
00013e  eb000080          ADD      r0,r0,r0,LSL #2       ;704
000142  eb060080          ADD      r0,r6,r0,LSL #2       ;704
000146  1d21              ADDS     r1,r4,#4              ;704
000148  f7fffffe          BL       vListInsertEnd
00014c  2401              MOVS     r4,#1                 ;706
00014e  f7fffffe          BL       vPortExitCritical
;;;714    		traceTASK_CREATE_FAILED();
;;;715    	}
;;;716    
;;;717    	if( xReturn == pdPASS )
;;;718    	{
;;;719    		if( xSchedulerRunning != pdFALSE )
000152  f8d80014          LDR      r0,[r8,#0x14]  ; xSchedulerRunning
000156  b130              CBZ      r0,|L1.358|
;;;720    		{
;;;721    			/* If the created task is of a higher priority than the current task
;;;722    			then it should run now. */
;;;723    			if( pxCurrentTCB->uxPriority < uxPriority )
000158  f8d80000          LDR      r0,[r8,#0]  ; pxCurrentTCB
00015c  6ac0              LDR      r0,[r0,#0x2c]
00015e  42b8              CMP      r0,r7
;;;724    			{
;;;725    				taskYIELD_IF_USING_PREEMPTION();
000160  bf38              IT       CC
000162  f7fffffe          BLCC     vPortYield
                  |L1.358|
;;;726    			}
;;;727    			else
;;;728    			{
;;;729    				mtCOVERAGE_TEST_MARKER();
;;;730    			}
;;;731    		}
;;;732    		else
;;;733    		{
;;;734    			mtCOVERAGE_TEST_MARKER();
;;;735    		}
;;;736    	}
;;;737    
;;;738    	return xReturn;
000166  4620              MOV      r0,r4
;;;739    }
000168  e8bd9ff0          POP      {r4-r12,pc}
;;;740    /*-----------------------------------------------------------*/
                          ENDP

                  vTaskDelete PROC
;;;743    
;;;744    	void vTaskDelete( TaskHandle_t xTaskToDelete )
00016c  b570              PUSH     {r4-r6,lr}
;;;745    	{
00016e  4605              MOV      r5,r0
;;;746    	TCB_t *pxTCB;
;;;747    
;;;748    		taskENTER_CRITICAL();
000170  f7fffffe          BL       vPortEnterCritical
;;;749    		{
;;;750    			/* If null is passed in here then it is the calling task that is
;;;751    			being deleted. */
;;;752    			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
000174  4ccb              LDR      r4,|L1.1188|
000176  2d00              CMP      r5,#0
000178  bf08              IT       EQ
00017a  6825              LDREQ    r5,[r4,#0]  ; pxCurrentTCB
;;;753    
;;;754    			/* Remove task from the ready list and place in the	termination list.
;;;755    			This will stop the task from be scheduled.  The idle task will check
;;;756    			the termination list and free up any memory allocated by the
;;;757    			scheduler for the TCB and stack. */
;;;758    			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00017c  1d28              ADDS     r0,r5,#4
00017e  f7fffffe          BL       uxListRemove
000182  b968              CBNZ     r0,|L1.416|
;;;759    			{
;;;760    				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000184  6ae8              LDR      r0,[r5,#0x2c]
000186  4ac8              LDR      r2,|L1.1192|
000188  eb000180          ADD      r1,r0,r0,LSL #2
00018c  f8521021          LDR      r1,[r2,r1,LSL #2]
000190  b931              CBNZ     r1,|L1.416|
000192  2101              MOVS     r1,#1
000194  fa01f000          LSL      r0,r1,r0
000198  6921              LDR      r1,[r4,#0x10]  ; uxTopReadyPriority
00019a  ea210000          BIC      r0,r1,r0
00019e  6120              STR      r0,[r4,#0x10]  ; uxTopReadyPriority
                  |L1.416|
;;;761    			}
;;;762    			else
;;;763    			{
;;;764    				mtCOVERAGE_TEST_MARKER();
;;;765    			}
;;;766    
;;;767    			/* Is the task waiting on an event also? */
;;;768    			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0001a0  6aa8              LDR      r0,[r5,#0x28]
0001a2  2800              CMP      r0,#0
;;;769    			{
;;;770    				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0001a4  bf1c              ITT      NE
0001a6  f1050018          ADDNE    r0,r5,#0x18
0001aa  f7fffffe          BLNE     uxListRemove
;;;771    			}
;;;772    			else
;;;773    			{
;;;774    				mtCOVERAGE_TEST_MARKER();
;;;775    			}
;;;776    
;;;777    			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
0001ae  1d29              ADDS     r1,r5,#4
0001b0  48c1              LDR      r0,|L1.1208|
0001b2  f7fffffe          BL       vListInsertEnd
;;;778    
;;;779    			/* Increment the ucTasksDeleted variable so the idle task knows
;;;780    			there is a task that has been deleted and that it should therefore
;;;781    			check the xTasksWaitingTermination list. */
;;;782    			++uxTasksDeleted;
0001b6  6860              LDR      r0,[r4,#4]  ; uxTasksDeleted
0001b8  1c40              ADDS     r0,r0,#1
0001ba  6060              STR      r0,[r4,#4]  ; uxTasksDeleted
;;;783    
;;;784    			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
;;;785    			can detect that the task lists need re-generating. */
;;;786    			uxTaskNumber++;
0001bc  6a60              LDR      r0,[r4,#0x24]  ; uxTaskNumber
0001be  1c40              ADDS     r0,r0,#1
;;;787    
;;;788    			traceTASK_DELETE( pxTCB );
;;;789    		}
;;;790    		taskEXIT_CRITICAL();
0001c0  6260              STR      r0,[r4,#0x24]  ; uxTaskNumber
0001c2  f7fffffe          BL       vPortExitCritical
;;;791    
;;;792    		/* Force a reschedule if it is the currently running task that has just
;;;793    		been deleted. */
;;;794    		if( xSchedulerRunning != pdFALSE )
0001c6  6960              LDR      r0,[r4,#0x14]  ; xSchedulerRunning
0001c8  2800              CMP      r0,#0
;;;795    		{
;;;796    			if( pxTCB == pxCurrentTCB )
;;;797    			{
;;;798    				configASSERT( uxSchedulerSuspended == 0 );
;;;799    
;;;800    				/* The pre-delete hook is primarily for the Windows simulator,
;;;801    				in which Windows specific clean up operations are performed,
;;;802    				after which it is not possible to yield away from this task -
;;;803    				hence xYieldPending is used to latch that a context switch is
;;;804    				required. */
;;;805    				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
;;;806    				portYIELD_WITHIN_API();
;;;807    			}
;;;808    			else
;;;809    			{
;;;810    				/* Reset the next expected unblock time in case it referred to
;;;811    				the task that has just been deleted. */
;;;812    				taskENTER_CRITICAL();
;;;813    				{
;;;814    					prvResetNextTaskUnblockTime();
;;;815    				}
;;;816    				taskEXIT_CRITICAL();
;;;817    			}
;;;818    		}
;;;819    	}
0001ca  bf08              IT       EQ
0001cc  bd70              POPEQ    {r4-r6,pc}
0001ce  6820              LDR      r0,[r4,#0]            ;796  ; pxCurrentTCB
0001d0  4285              CMP      r5,r0                 ;796
0001d2  d103              BNE      |L1.476|
0001d4  e8bd4070          POP      {r4-r6,lr}            ;806
0001d8  f7ffbffe          B.W      vPortYield
                  |L1.476|
0001dc  f7fffffe          BL       vPortEnterCritical
0001e0  6b20              LDR      r0,[r4,#0x30]         ;812  ; pxDelayedTaskList
0001e2  6800              LDR      r0,[r0,#0]            ;812
0001e4  2800              CMP      r0,#0                 ;812
0001e6  bf0f              ITEEE    EQ                    ;812
0001e8  f04f30ff          MOVEQ    r0,#0xffffffff        ;812
0001ec  6b20              LDRNE    r0,[r4,#0x30]         ;812  ; pxDelayedTaskList
0001ee  68c0              LDRNE    r0,[r0,#0xc]          ;812
0001f0  68c0              LDRNE    r0,[r0,#0xc]          ;812
0001f2  bf18              IT       NE                    ;812
0001f4  6840              LDRNE    r0,[r0,#4]            ;812
0001f6  62a0              STR      r0,[r4,#0x28]         ;812  ; xNextTaskUnblockTime
0001f8  e8bd4070          POP      {r4-r6,lr}            ;816
0001fc  f7ffbffe          B.W      vPortExitCritical
;;;820    
                          ENDP

                  xTaskIncrementTick PROC
;;;1937   
;;;1938   BaseType_t xTaskIncrementTick( void )
000200  e92d47f0          PUSH     {r4-r10,lr}
;;;1939   {
;;;1940   TCB_t * pxTCB;
;;;1941   TickType_t xItemValue;
;;;1942   BaseType_t xSwitchRequired = pdFALSE;
;;;1943   
;;;1944   	/* Called by the portable layer each time a tick interrupt occurs.
;;;1945   	Increments the tick then checks to see if the new tick value will cause any
;;;1946   	tasks to be unblocked. */
;;;1947   	traceTASK_INCREMENT_TICK( xTickCount );
;;;1948   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000204  4da7              LDR      r5,|L1.1188|
000206  2600              MOVS     r6,#0                 ;1942
000208  6ae8              LDR      r0,[r5,#0x2c]  ; uxSchedulerSuspended
00020a  b148              CBZ      r0,|L1.544|
;;;1949   	{
;;;1950   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;1951   		delayed lists if it wraps to 0. */
;;;1952   		++xTickCount;
;;;1953   
;;;1954   		{
;;;1955   			/* Minor optimisation.  The tick count cannot change in this
;;;1956   			block. */
;;;1957   			const TickType_t xConstTickCount = xTickCount;
;;;1958   
;;;1959   			if( xConstTickCount == ( TickType_t ) 0U )
;;;1960   			{
;;;1961   				taskSWITCH_DELAYED_LISTS();
;;;1962   			}
;;;1963   			else
;;;1964   			{
;;;1965   				mtCOVERAGE_TEST_MARKER();
;;;1966   			}
;;;1967   
;;;1968   			/* See if this tick has made a timeout expire.  Tasks are stored in
;;;1969   			the	queue in the order of their wake time - meaning once one task
;;;1970   			has been found whose block time has not expired there is no need to
;;;1971   			look any further down the list. */
;;;1972   			if( xConstTickCount >= xNextTaskUnblockTime )
;;;1973   			{
;;;1974   				for( ;; )
;;;1975   				{
;;;1976   					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
;;;1977   					{
;;;1978   						/* The delayed list is empty.  Set xNextTaskUnblockTime
;;;1979   						to the maximum possible value so it is extremely
;;;1980   						unlikely that the
;;;1981   						if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;1982   						next time through. */
;;;1983   						xNextTaskUnblockTime = portMAX_DELAY;
;;;1984   						break;
;;;1985   					}
;;;1986   					else
;;;1987   					{
;;;1988   						/* The delayed list is not empty, get the value of the
;;;1989   						item at the head of the delayed list.  This is the time
;;;1990   						at which the task at the head of the delayed list must
;;;1991   						be removed from the Blocked state. */
;;;1992   						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
;;;1993   						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
;;;1994   
;;;1995   						if( xConstTickCount < xItemValue )
;;;1996   						{
;;;1997   							/* It is not time to unblock this item yet, but the
;;;1998   							item value is the time at which the task at the head
;;;1999   							of the blocked list must be removed from the Blocked
;;;2000   							state -	so record the item value in
;;;2001   							xNextTaskUnblockTime. */
;;;2002   							xNextTaskUnblockTime = xItemValue;
;;;2003   							break;
;;;2004   						}
;;;2005   						else
;;;2006   						{
;;;2007   							mtCOVERAGE_TEST_MARKER();
;;;2008   						}
;;;2009   
;;;2010   						/* It is time to remove the item from the Blocked state. */
;;;2011   						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
;;;2012   
;;;2013   						/* Is the task waiting on an event also?  If so remove
;;;2014   						it from the event list. */
;;;2015   						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
;;;2016   						{
;;;2017   							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
;;;2018   						}
;;;2019   						else
;;;2020   						{
;;;2021   							mtCOVERAGE_TEST_MARKER();
;;;2022   						}
;;;2023   
;;;2024   						/* Place the unblocked task into the appropriate ready
;;;2025   						list. */
;;;2026   						prvAddTaskToReadyList( pxTCB );
;;;2027   
;;;2028   						/* A task being unblocked cannot cause an immediate
;;;2029   						context switch if preemption is turned off. */
;;;2030   						#if (  configUSE_PREEMPTION == 1 )
;;;2031   						{
;;;2032   							/* Preemption is on, but a context switch should
;;;2033   							only be performed if the unblocked task has a
;;;2034   							priority that is equal to or higher than the
;;;2035   							currently executing task. */
;;;2036   							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;2037   							{
;;;2038   								xSwitchRequired = pdTRUE;
;;;2039   							}
;;;2040   							else
;;;2041   							{
;;;2042   								mtCOVERAGE_TEST_MARKER();
;;;2043   							}
;;;2044   						}
;;;2045   						#endif /* configUSE_PREEMPTION */
;;;2046   					}
;;;2047   				}
;;;2048   			}
;;;2049   		}
;;;2050   
;;;2051   		/* Tasks of equal priority to the currently running task will share
;;;2052   		processing time (time slice) if preemption is on, and the application
;;;2053   		writer has not explicitly turned time slicing off. */
;;;2054   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;2055   		{
;;;2056   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
;;;2057   			{
;;;2058   				xSwitchRequired = pdTRUE;
;;;2059   			}
;;;2060   			else
;;;2061   			{
;;;2062   				mtCOVERAGE_TEST_MARKER();
;;;2063   			}
;;;2064   		}
;;;2065   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;2066   
;;;2067   		#if ( configUSE_TICK_HOOK == 1 )
;;;2068   		{
;;;2069   			/* Guard against the tick hook being called when the pended tick
;;;2070   			count is being unwound (when the scheduler is being unlocked). */
;;;2071   			if( uxPendedTicks == ( UBaseType_t ) 0U )
;;;2072   			{
;;;2073   				vApplicationTickHook();
;;;2074   			}
;;;2075   			else
;;;2076   			{
;;;2077   				mtCOVERAGE_TEST_MARKER();
;;;2078   			}
;;;2079   		}
;;;2080   		#endif /* configUSE_TICK_HOOK */
;;;2081   	}
;;;2082   	else
;;;2083   	{
;;;2084   		++uxPendedTicks;
00020c  69a8              LDR      r0,[r5,#0x18]  ; uxPendedTicks
00020e  1c40              ADDS     r0,r0,#1
000210  61a8              STR      r0,[r5,#0x18]  ; uxPendedTicks
                  |L1.530|
;;;2085   
;;;2086   		/* The tick hook gets called at regular intervals, even if the
;;;2087   		scheduler is locked. */
;;;2088   		#if ( configUSE_TICK_HOOK == 1 )
;;;2089   		{
;;;2090   			vApplicationTickHook();
;;;2091   		}
;;;2092   		#endif
;;;2093   	}
;;;2094   
;;;2095   	#if ( configUSE_PREEMPTION == 1 )
;;;2096   	{
;;;2097   		if( xYieldPending != pdFALSE )
000212  69e8              LDR      r0,[r5,#0x1c]  ; xYieldPending
000214  2800              CMP      r0,#0
;;;2098   		{
;;;2099   			xSwitchRequired = pdTRUE;
000216  bf18              IT       NE
000218  2601              MOVNE    r6,#1
;;;2100   		}
;;;2101   		else
;;;2102   		{
;;;2103   			mtCOVERAGE_TEST_MARKER();
;;;2104   		}
;;;2105   	}
;;;2106   	#endif /* configUSE_PREEMPTION */
;;;2107   
;;;2108   	return xSwitchRequired;
00021a  4630              MOV      r0,r6
;;;2109   }
00021c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.544|
000220  68e8              LDR      r0,[r5,#0xc]          ;1952  ; xTickCount
000222  1c40              ADDS     r0,r0,#1              ;1952
000224  60e8              STR      r0,[r5,#0xc]          ;1952  ; xTickCount
000226  68ef              LDR      r7,[r5,#0xc]          ;1957  ; xTickCount
000228  f04f39ff          MOV      r9,#0xffffffff        ;1957
00022c  b997              CBNZ     r7,|L1.596|
00022e  6b28              LDR      r0,[r5,#0x30]         ;1961  ; pxDelayedTaskList
000230  6b69              LDR      r1,[r5,#0x34]         ;1961  ; pxOverflowDelayedTaskList
000232  6329              STR      r1,[r5,#0x30]         ;1961  ; pxDelayedTaskList
000234  6368              STR      r0,[r5,#0x34]         ;1961  ; pxOverflowDelayedTaskList
000236  6a28              LDR      r0,[r5,#0x20]         ;1961  ; xNumOfOverflows
000238  1c40              ADDS     r0,r0,#1              ;1961
00023a  6228              STR      r0,[r5,#0x20]         ;1961  ; xNumOfOverflows
00023c  6b28              LDR      r0,[r5,#0x30]         ;1961  ; pxDelayedTaskList
00023e  6800              LDR      r0,[r0,#0]            ;1961
000240  2800              CMP      r0,#0                 ;1961
000242  bf08              IT       EQ                    ;1961
000244  f8c59028          STREQ    r9,[r5,#0x28]         ;1961  ; xNextTaskUnblockTime
000248  d004              BEQ      |L1.596|
00024a  6b28              LDR      r0,[r5,#0x30]         ;1961  ; pxDelayedTaskList
00024c  68c0              LDR      r0,[r0,#0xc]          ;1961
00024e  68c0              LDR      r0,[r0,#0xc]          ;1961
000250  6840              LDR      r0,[r0,#4]            ;1961
000252  62a8              STR      r0,[r5,#0x28]         ;1961  ; xNextTaskUnblockTime
                  |L1.596|
000254  6aa8              LDR      r0,[r5,#0x28]         ;1972  ; xNextTaskUnblockTime
000256  f8df8250          LDR      r8,|L1.1192|
00025a  4287              CMP      r7,r0                 ;1972
00025c  bf28              IT       CS                    ;2026
00025e  f04f0a01          MOVCS    r10,#1                ;2026
000262  d30c              BCC      |L1.638|
                  |L1.612|
000264  6b28              LDR      r0,[r5,#0x30]         ;1976  ; pxDelayedTaskList
000266  6800              LDR      r0,[r0,#0]            ;1976
000268  b138              CBZ      r0,|L1.634|
00026a  6b28              LDR      r0,[r5,#0x30]         ;1992  ; pxDelayedTaskList
00026c  68c0              LDR      r0,[r0,#0xc]          ;1992
00026e  68c4              LDR      r4,[r0,#0xc]          ;1993
000270  6860              LDR      r0,[r4,#4]            ;1995
000272  4287              CMP      r7,r0                 ;1995
000274  d20d              BCS      |L1.658|
000276  62a8              STR      r0,[r5,#0x28]         ;2002  ; xNextTaskUnblockTime
000278  e001              B        |L1.638|
                  |L1.634|
00027a  f8c59028          STR      r9,[r5,#0x28]         ;1983  ; xNextTaskUnblockTime
                  |L1.638|
00027e  6828              LDR      r0,[r5,#0]            ;2056  ; pxCurrentTCB
000280  6ac0              LDR      r0,[r0,#0x2c]         ;2056
000282  eb000080          ADD      r0,r0,r0,LSL #2       ;2056
000286  f8580020          LDR      r0,[r8,r0,LSL #2]     ;2056
00028a  2801              CMP      r0,#1                 ;2056
00028c  bf88              IT       HI                    ;2058
00028e  2601              MOVHI    r6,#1                 ;2058
000290  e7bf              B        |L1.530|
                  |L1.658|
000292  1d20              ADDS     r0,r4,#4              ;2011
000294  f7fffffe          BL       uxListRemove
000298  6aa0              LDR      r0,[r4,#0x28]         ;2015
00029a  2800              CMP      r0,#0                 ;2015
00029c  bf1c              ITT      NE                    ;2017
00029e  f1040018          ADDNE    r0,r4,#0x18           ;2017
0002a2  f7fffffe          BLNE     uxListRemove
0002a6  6ae0              LDR      r0,[r4,#0x2c]         ;2026
0002a8  692a              LDR      r2,[r5,#0x10]         ;2026  ; uxTopReadyPriority
0002aa  fa0af100          LSL      r1,r10,r0             ;2026
0002ae  4311              ORRS     r1,r1,r2              ;2026
0002b0  6129              STR      r1,[r5,#0x10]         ;2026  ; uxTopReadyPriority
0002b2  eb000080          ADD      r0,r0,r0,LSL #2       ;2026
0002b6  eb080080          ADD      r0,r8,r0,LSL #2       ;2026
0002ba  1d21              ADDS     r1,r4,#4              ;2026
0002bc  f7fffffe          BL       vListInsertEnd
0002c0  6ae0              LDR      r0,[r4,#0x2c]         ;2036
0002c2  6829              LDR      r1,[r5,#0]            ;2036  ; pxCurrentTCB
0002c4  6ac9              LDR      r1,[r1,#0x2c]         ;2036
0002c6  4288              CMP      r0,r1                 ;2036
0002c8  bf28              IT       CS                    ;2038
0002ca  2601              MOVCS    r6,#1                 ;2038
0002cc  e7ca              B        |L1.612|
;;;2110   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskResumeAll PROC
;;;1669   
;;;1670   BaseType_t xTaskResumeAll( void )
0002ce  e92d5ff0          PUSH     {r4-r12,lr}
;;;1671   {
;;;1672   TCB_t *pxTCB;
;;;1673   BaseType_t xAlreadyYielded = pdFALSE;
0002d2  f04f0a00          MOV      r10,#0
;;;1674   
;;;1675   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;1676   	previous call to vTaskSuspendAll(). */
;;;1677   	configASSERT( uxSchedulerSuspended );
;;;1678   
;;;1679   	/* It is possible that an ISR caused a task to be removed from an event
;;;1680   	list while the scheduler was suspended.  If this was the case then the
;;;1681   	removed task will have been added to the xPendingReadyList.  Once the
;;;1682   	scheduler has been resumed it is safe to move all the pending ready
;;;1683   	tasks from this list into their appropriate ready list. */
;;;1684   	taskENTER_CRITICAL();
0002d6  f7fffffe          BL       vPortEnterCritical
;;;1685   	{
;;;1686   		--uxSchedulerSuspended;
0002da  4d72              LDR      r5,|L1.1188|
0002dc  6ae8              LDR      r0,[r5,#0x2c]  ; uxSchedulerSuspended
0002de  1e40              SUBS     r0,r0,#1
0002e0  62e8              STR      r0,[r5,#0x2c]  ; uxSchedulerSuspended
;;;1687   
;;;1688   		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
0002e2  6ae8              LDR      r0,[r5,#0x2c]  ; uxSchedulerSuspended
0002e4  2800              CMP      r0,#0
0002e6  d14e              BNE      |L1.902|
;;;1689   		{
;;;1690   			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
0002e8  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
0002ea  2800              CMP      r0,#0
0002ec  d04b              BEQ      |L1.902|
;;;1691   			{
;;;1692   				/* Move any readied tasks from the pending list into the
;;;1693   				appropriate ready list. */
;;;1694   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
0002ee  4e71              LDR      r6,|L1.1204|
;;;1695   				{
;;;1696   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
;;;1697   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
;;;1698   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
;;;1699   					prvAddTaskToReadyList( pxTCB );
0002f0  f04f0901          MOV      r9,#1
0002f4  f1a6078c          SUB      r7,r6,#0x8c
0002f8  6830              LDR      r0,[r6,#0]            ;1694  ; xPendingReadyList
0002fa  b1f8              CBZ      r0,|L1.828|
                  |L1.764|
0002fc  68f0              LDR      r0,[r6,#0xc]          ;1696  ; xPendingReadyList
0002fe  68c4              LDR      r4,[r0,#0xc]          ;1697
000300  f1040018          ADD      r0,r4,#0x18           ;1697
000304  f7fffffe          BL       uxListRemove
000308  1d20              ADDS     r0,r4,#4              ;1698
00030a  f7fffffe          BL       uxListRemove
00030e  6ae0              LDR      r0,[r4,#0x2c]
000310  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000312  fa09f100          LSL      r1,r9,r0
000316  4311              ORRS     r1,r1,r2
000318  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
00031a  eb000080          ADD      r0,r0,r0,LSL #2
00031e  eb070080          ADD      r0,r7,r0,LSL #2
000322  1d21              ADDS     r1,r4,#4
000324  f7fffffe          BL       vListInsertEnd
;;;1700   
;;;1701   					/* If the moved task has a priority higher than the current
;;;1702   					task then a yield must be performed. */
;;;1703   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000328  6ae1              LDR      r1,[r4,#0x2c]
00032a  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00032c  6ac0              LDR      r0,[r0,#0x2c]
00032e  4281              CMP      r1,r0
;;;1704   					{
;;;1705   						xYieldPending = pdTRUE;
000330  bf28              IT       CS
000332  f8c5901c          STRCS    r9,[r5,#0x1c]  ; xYieldPending
000336  6830              LDR      r0,[r6,#0]            ;1694  ; xPendingReadyList
000338  2800              CMP      r0,#0                 ;1694
00033a  d1df              BNE      |L1.764|
                  |L1.828|
;;;1706   					}
;;;1707   					else
;;;1708   					{
;;;1709   						mtCOVERAGE_TEST_MARKER();
;;;1710   					}
;;;1711   				}
;;;1712   
;;;1713   				/* If any ticks occurred while the scheduler was suspended then
;;;1714   				they should be processed now.  This ensures the tick count does
;;;1715   				not	slip, and that any delayed tasks are resumed at the correct
;;;1716   				time. */
;;;1717   				if( uxPendedTicks > ( UBaseType_t ) 0U )
00033c  69a8              LDR      r0,[r5,#0x18]  ; uxPendedTicks
00033e  2800              CMP      r0,#0
;;;1718   				{
;;;1719   					while( uxPendedTicks > ( UBaseType_t ) 0U )
000340  bf1e              ITTT     NE
000342  69a8              LDRNE    r0,[r5,#0x18]  ; uxPendedTicks
000344  2800              CMPNE    r0,#0
000346  f04f3bff          MOVNE    r11,#0xffffffff
00034a  d015              BEQ      |L1.888|
                  |L1.844|
00034c  6ae8              LDR      r0,[r5,#0x2c]         ;1717  ; uxSchedulerSuspended
00034e  f04f0800          MOV      r8,#0                 ;1717
000352  b1e8              CBZ      r0,|L1.912|
000354  69a8              LDR      r0,[r5,#0x18]         ;1717  ; uxPendedTicks
000356  1c40              ADDS     r0,r0,#1              ;1717
000358  61a8              STR      r0,[r5,#0x18]         ;1717  ; uxPendedTicks
                  |L1.858|
00035a  69e8              LDR      r0,[r5,#0x1c]         ;1717  ; xYieldPending
00035c  2800              CMP      r0,#0                 ;1717
;;;1720   					{
;;;1721   						if( xTaskIncrementTick() != pdFALSE )
00035e  bf08              IT       EQ
000360  f1b80f00          CMPEQ    r8,#0
000364  d002              BEQ      |L1.876|
;;;1722   						{
;;;1723   							xYieldPending = pdTRUE;
000366  bf00              NOP      
                  |L1.872|
000368  f8c5901c          STR      r9,[r5,#0x1c]  ; xYieldPending
                  |L1.876|
;;;1724   						}
;;;1725   						else
;;;1726   						{
;;;1727   							mtCOVERAGE_TEST_MARKER();
;;;1728   						}
;;;1729   						--uxPendedTicks;
00036c  69a8              LDR      r0,[r5,#0x18]  ; uxPendedTicks
00036e  1e40              SUBS     r0,r0,#1
000370  61a8              STR      r0,[r5,#0x18]  ; uxPendedTicks
000372  69a8              LDR      r0,[r5,#0x18]         ;1719  ; uxPendedTicks
000374  2800              CMP      r0,#0                 ;1719
000376  d1e9              BNE      |L1.844|
                  |L1.888|
;;;1730   					}
;;;1731   				}
;;;1732   				else
;;;1733   				{
;;;1734   					mtCOVERAGE_TEST_MARKER();
;;;1735   				}
;;;1736   
;;;1737   				if( xYieldPending == pdTRUE )
000378  69e8              LDR      r0,[r5,#0x1c]  ; xYieldPending
00037a  2801              CMP      r0,#1
;;;1738   				{
;;;1739   					#if( configUSE_PREEMPTION != 0 )
;;;1740   					{
;;;1741   						xAlreadyYielded = pdTRUE;
00037c  bf04              ITT      EQ
00037e  f04f0a01          MOVEQ    r10,#1
;;;1742   					}
;;;1743   					#endif
;;;1744   					taskYIELD_IF_USING_PREEMPTION();
000382  f7fffffe          BLEQ     vPortYield
                  |L1.902|
;;;1745   				}
;;;1746   				else
;;;1747   				{
;;;1748   					mtCOVERAGE_TEST_MARKER();
;;;1749   				}
;;;1750   			}
;;;1751   		}
;;;1752   		else
;;;1753   		{
;;;1754   			mtCOVERAGE_TEST_MARKER();
;;;1755   		}
;;;1756   	}
;;;1757   	taskEXIT_CRITICAL();
000386  f7fffffe          BL       vPortExitCritical
;;;1758   
;;;1759   	return xAlreadyYielded;
00038a  4650              MOV      r0,r10
;;;1760   }
00038c  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.912|
000390  68e8              LDR      r0,[r5,#0xc]  ; xTickCount
000392  1c40              ADDS     r0,r0,#1
000394  60e8              STR      r0,[r5,#0xc]  ; xTickCount
000396  68ee              LDR      r6,[r5,#0xc]  ; xTickCount
000398  b996              CBNZ     r6,|L1.960|
00039a  6b28              LDR      r0,[r5,#0x30]  ; pxDelayedTaskList
00039c  6b69              LDR      r1,[r5,#0x34]  ; pxOverflowDelayedTaskList
00039e  6329              STR      r1,[r5,#0x30]  ; pxDelayedTaskList
0003a0  6368              STR      r0,[r5,#0x34]  ; pxOverflowDelayedTaskList
0003a2  6a28              LDR      r0,[r5,#0x20]  ; xNumOfOverflows
0003a4  1c40              ADDS     r0,r0,#1
0003a6  6228              STR      r0,[r5,#0x20]  ; xNumOfOverflows
0003a8  6b28              LDR      r0,[r5,#0x30]  ; pxDelayedTaskList
0003aa  6800              LDR      r0,[r0,#0]
0003ac  2800              CMP      r0,#0
0003ae  bf08              IT       EQ
0003b0  f8c5b028          STREQ    r11,[r5,#0x28]  ; xNextTaskUnblockTime
0003b4  d004              BEQ      |L1.960|
0003b6  6b28              LDR      r0,[r5,#0x30]  ; pxDelayedTaskList
0003b8  68c0              LDR      r0,[r0,#0xc]
0003ba  68c0              LDR      r0,[r0,#0xc]
0003bc  6840              LDR      r0,[r0,#4]
0003be  62a8              STR      r0,[r5,#0x28]  ; xNextTaskUnblockTime
                  |L1.960|
0003c0  6aa8              LDR      r0,[r5,#0x28]  ; xNextTaskUnblockTime
0003c2  4286              CMP      r6,r0
0003c4  d30c              BCC      |L1.992|
                  |L1.966|
0003c6  6b28              LDR      r0,[r5,#0x30]  ; pxDelayedTaskList
0003c8  6800              LDR      r0,[r0,#0]
0003ca  b138              CBZ      r0,|L1.988|
0003cc  6b28              LDR      r0,[r5,#0x30]  ; pxDelayedTaskList
0003ce  68c0              LDR      r0,[r0,#0xc]
0003d0  68c4              LDR      r4,[r0,#0xc]
0003d2  6860              LDR      r0,[r4,#4]
0003d4  4286              CMP      r6,r0
0003d6  d20f              BCS      |L1.1016|
0003d8  62a8              STR      r0,[r5,#0x28]  ; xNextTaskUnblockTime
0003da  e001              B        |L1.992|
                  |L1.988|
0003dc  f8c5b028          STR      r11,[r5,#0x28]  ; xNextTaskUnblockTime
                  |L1.992|
0003e0  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
0003e2  4628              MOV      r0,r5
0003e4  6ac9              LDR      r1,[r1,#0x2c]
0003e6  eb010181          ADD      r1,r1,r1,LSL #2
0003ea  f8571021          LDR      r1,[r7,r1,LSL #2]
0003ee  2901              CMP      r1,#1
0003f0  bf88              IT       HI
0003f2  69c0              LDRHI    r0,[r0,#0x1c]  ; xYieldPending
0003f4  d8b8              BHI      |L1.872|
0003f6  e7b0              B        |L1.858|
                  |L1.1016|
0003f8  1d20              ADDS     r0,r4,#4
0003fa  f7fffffe          BL       uxListRemove
0003fe  6aa0              LDR      r0,[r4,#0x28]
000400  2800              CMP      r0,#0
000402  bf1c              ITT      NE
000404  f1040018          ADDNE    r0,r4,#0x18
000408  f7fffffe          BLNE     uxListRemove
00040c  6ae0              LDR      r0,[r4,#0x2c]
00040e  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000410  fa09f100          LSL      r1,r9,r0
000414  4311              ORRS     r1,r1,r2
000416  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
000418  eb000080          ADD      r0,r0,r0,LSL #2
00041c  eb070080          ADD      r0,r7,r0,LSL #2
000420  1d21              ADDS     r1,r4,#4
000422  f7fffffe          BL       vListInsertEnd
000426  6ae0              LDR      r0,[r4,#0x2c]
000428  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
00042a  6ac9              LDR      r1,[r1,#0x2c]
00042c  4288              CMP      r0,r1
00042e  bf28              IT       CS
000430  f04f0801          MOVCS    r8,#1
000434  e7c7              B        |L1.966|
;;;1761   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSuspendAll PROC
;;;1631   
;;;1632   void vTaskSuspendAll( void )
000436  481b              LDR      r0,|L1.1188|
;;;1633   {
;;;1634   	/* A critical section is not required as the variable is of type
;;;1635   	BaseType_t.  Please read Richard Barry's reply in the following link to a
;;;1636   	post in the FreeRTOS support forum before reporting this as a bug! -
;;;1637   	http://goo.gl/wu4acr */
;;;1638   	++uxSchedulerSuspended;
000438  6ac1              LDR      r1,[r0,#0x2c]  ; uxSchedulerSuspended
00043a  1c49              ADDS     r1,r1,#1
00043c  62c1              STR      r1,[r0,#0x2c]  ; uxSchedulerSuspended
;;;1639   }
00043e  4770              BX       lr
;;;1640   /*----------------------------------------------------------*/
                          ENDP

                  vTaskDelayUntil PROC
;;;825    
;;;826    	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
000440  b570              PUSH     {r4-r6,lr}
000442  4d18              LDR      r5,|L1.1188|
000444  6aea              LDR      r2,[r5,#0x2c]  ; uxSchedulerSuspended
000446  1c52              ADDS     r2,r2,#1
000448  62ea              STR      r2,[r5,#0x2c]  ; uxSchedulerSuspended
;;;827    	{
;;;828    	TickType_t xTimeToWake;
;;;829    	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
;;;830    
;;;831    		configASSERT( pxPreviousWakeTime );
;;;832    		configASSERT( ( xTimeIncrement > 0U ) );
;;;833    		configASSERT( uxSchedulerSuspended == 0 );
;;;834    
;;;835    		vTaskSuspendAll();
;;;836    		{
;;;837    			/* Minor optimisation.  The tick count cannot change in this
;;;838    			block. */
;;;839    			const TickType_t xConstTickCount = xTickCount;
00044a  68eb              LDR      r3,[r5,#0xc]  ; xTickCount
;;;840    
;;;841    			/* Generate the tick time at which the task wants to wake. */
;;;842    			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
00044c  6802              LDR      r2,[r0,#0]
00044e  1854              ADDS     r4,r2,r1
;;;843    
;;;844    			if( xConstTickCount < *pxPreviousWakeTime )
000450  429a              CMP      r2,r3
000452  d904              BLS      |L1.1118|
;;;845    			{
;;;846    				/* The tick count has overflowed since this function was
;;;847    				lasted called.  In this case the only time we should ever
;;;848    				actually delay is if the wake time has also	overflowed,
;;;849    				and the wake time is greater than the tick time.  When this
;;;850    				is the case it is as if neither time had overflowed. */
;;;851    				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
000454  42a2              CMP      r2,r4
000456  bf88              IT       HI
000458  429c              CMPHI    r4,r3
00045a  d90b              BLS      |L1.1140|
00045c  e003              B        |L1.1126|
                  |L1.1118|
;;;852    				{
;;;853    					xShouldDelay = pdTRUE;
;;;854    				}
;;;855    				else
;;;856    				{
;;;857    					mtCOVERAGE_TEST_MARKER();
;;;858    				}
;;;859    			}
;;;860    			else
;;;861    			{
;;;862    				/* The tick time has not overflowed.  In this case we will
;;;863    				delay if either the wake time has overflowed, and/or the
;;;864    				tick time is less than the wake time. */
;;;865    				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
00045e  42a2              CMP      r2,r4
000460  bf98              IT       LS
000462  429c              CMPLS    r4,r3
000464  d906              BLS      |L1.1140|
                  |L1.1126|
;;;866    				{
;;;867    					xShouldDelay = pdTRUE;
;;;868    				}
;;;869    				else
;;;870    				{
;;;871    					mtCOVERAGE_TEST_MARKER();
;;;872    				}
;;;873    			}
;;;874    
;;;875    			/* Update the wake time ready for the next call. */
;;;876    			*pxPreviousWakeTime = xTimeToWake;
;;;877    
;;;878    			if( xShouldDelay != pdFALSE )
;;;879    			{
;;;880    				traceTASK_DELAY_UNTIL();
;;;881    
;;;882    				/* Remove the task from the ready list before adding it to the
;;;883    				blocked list as the same list item is used for both lists. */
;;;884    				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000466  6004              STR      r4,[r0,#0]
000468  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00046a  1d00              ADDS     r0,r0,#4
00046c  f7fffffe          BL       uxListRemove
000470  b960              CBNZ     r0,|L1.1164|
000472  e001              B        |L1.1144|
                  |L1.1140|
000474  6004              STR      r4,[r0,#0]            ;878
000476  e00c              B        |L1.1170|
                  |L1.1144|
;;;885    				{
;;;886    					/* The current task must be in a ready list, so there is
;;;887    					no need to check, and the port reset macro can be called
;;;888    					directly. */
;;;889    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000478  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00047a  2101              MOVS     r1,#1
00047c  f890002c          LDRB     r0,[r0,#0x2c]
000480  fa01f000          LSL      r0,r1,r0
000484  6929              LDR      r1,[r5,#0x10]  ; uxTopReadyPriority
000486  ea210000          BIC      r0,r1,r0
00048a  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L1.1164|
;;;890    				}
;;;891    				else
;;;892    				{
;;;893    					mtCOVERAGE_TEST_MARKER();
;;;894    				}
;;;895    
;;;896    				prvAddCurrentTaskToDelayedList( xTimeToWake );
00048c  4620              MOV      r0,r4
00048e  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L1.1170|
;;;897    			}
;;;898    			else
;;;899    			{
;;;900    				mtCOVERAGE_TEST_MARKER();
;;;901    			}
;;;902    		}
;;;903    		xAlreadyYielded = xTaskResumeAll();
000492  f7fffffe          BL       xTaskResumeAll
;;;904    
;;;905    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;906    		have put ourselves to sleep. */
;;;907    		if( xAlreadyYielded == pdFALSE )
000496  2800              CMP      r0,#0
;;;908    		{
;;;909    			portYIELD_WITHIN_API();
;;;910    		}
;;;911    		else
;;;912    		{
;;;913    			mtCOVERAGE_TEST_MARKER();
;;;914    		}
;;;915    	}
000498  bf18              IT       NE
00049a  bd70              POPNE    {r4-r6,pc}
00049c  e8bd4070          POP      {r4-r6,lr}            ;909
0004a0  f7ffbffe          B.W      vPortYield
                  |L1.1188|
                          DCD      ||.data||
                  |L1.1192|
                          DCD      ||.bss||
                  |L1.1196|
                          DCD      ||.bss||+0x64
                  |L1.1200|
                          DCD      ||.bss||+0x78
                  |L1.1204|
                          DCD      ||.bss||+0x8c
                  |L1.1208|
                          DCD      ||.bss||+0xa0
                  |L1.1212|
                          DCD      ||.bss||+0xb4
                          ENDP

                  vTaskDelay PROC
;;;921    
;;;922    	void vTaskDelay( const TickType_t xTicksToDelay )
0004c0  b570              PUSH     {r4-r6,lr}
;;;923    	{
0004c2  b1e0              CBZ      r0,|L1.1278|
0004c4  4cfe              LDR      r4,|L1.2240|
0004c6  6ae1              LDR      r1,[r4,#0x2c]  ; uxSchedulerSuspended
0004c8  1c49              ADDS     r1,r1,#1
0004ca  62e1              STR      r1,[r4,#0x2c]  ; uxSchedulerSuspended
;;;924    	TickType_t xTimeToWake;
;;;925    	BaseType_t xAlreadyYielded = pdFALSE;
;;;926    
;;;927    
;;;928    		/* A delay time of zero just forces a reschedule. */
;;;929    		if( xTicksToDelay > ( TickType_t ) 0U )
;;;930    		{
;;;931    			configASSERT( uxSchedulerSuspended == 0 );
;;;932    			vTaskSuspendAll();
;;;933    			{
;;;934    				traceTASK_DELAY();
;;;935    
;;;936    				/* A task that is removed from the event list while the
;;;937    				scheduler is suspended will not get placed in the ready
;;;938    				list or removed from the blocked list until the scheduler
;;;939    				is resumed.
;;;940    
;;;941    				This task cannot be in an event list as it is the currently
;;;942    				executing task. */
;;;943    
;;;944    				/* Calculate the time to wake - this may overflow but this is
;;;945    				not a problem. */
;;;946    				xTimeToWake = xTickCount + xTicksToDelay;
0004cc  68e1              LDR      r1,[r4,#0xc]  ; xTickCount
0004ce  180d              ADDS     r5,r1,r0
;;;947    
;;;948    				/* We must remove ourselves from the ready list before adding
;;;949    				ourselves to the blocked list as the same list item is used for
;;;950    				both lists. */
;;;951    				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
0004d0  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
0004d2  1d00              ADDS     r0,r0,#4
0004d4  f7fffffe          BL       uxListRemove
0004d8  b948              CBNZ     r0,|L1.1262|
;;;952    				{
;;;953    					/* The current task must be in a ready list, so there is
;;;954    					no need to check, and the port reset macro can be called
;;;955    					directly. */
;;;956    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
0004da  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
0004dc  2101              MOVS     r1,#1
0004de  f890002c          LDRB     r0,[r0,#0x2c]
0004e2  fa01f000          LSL      r0,r1,r0
0004e6  6921              LDR      r1,[r4,#0x10]  ; uxTopReadyPriority
0004e8  ea210000          BIC      r0,r1,r0
0004ec  6120              STR      r0,[r4,#0x10]  ; uxTopReadyPriority
                  |L1.1262|
;;;957    				}
;;;958    				else
;;;959    				{
;;;960    					mtCOVERAGE_TEST_MARKER();
;;;961    				}
;;;962    				prvAddCurrentTaskToDelayedList( xTimeToWake );
0004ee  4628              MOV      r0,r5
0004f0  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;963    			}
;;;964    			xAlreadyYielded = xTaskResumeAll();
0004f4  f7fffffe          BL       xTaskResumeAll
0004f8  2800              CMP      r0,#0
;;;965    		}
;;;966    		else
;;;967    		{
;;;968    			mtCOVERAGE_TEST_MARKER();
;;;969    		}
;;;970    
;;;971    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;972    		have put ourselves to sleep. */
;;;973    		if( xAlreadyYielded == pdFALSE )
;;;974    		{
;;;975    			portYIELD_WITHIN_API();
;;;976    		}
;;;977    		else
;;;978    		{
;;;979    			mtCOVERAGE_TEST_MARKER();
;;;980    		}
;;;981    	}
0004fa  bf18              IT       NE
0004fc  bd70              POPNE    {r4-r6,pc}
                  |L1.1278|
0004fe  e8bd4070          POP      {r4-r6,lr}            ;975
000502  f7ffbffe          B.W      vPortYield
;;;982    
                          ENDP

                  uxTaskPriorityGet PROC
;;;1057   
;;;1058   	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
000506  b510              PUSH     {r4,lr}
;;;1059   	{
000508  4604              MOV      r4,r0
;;;1060   	TCB_t *pxTCB;
;;;1061   	UBaseType_t uxReturn;
;;;1062   
;;;1063   		taskENTER_CRITICAL();
00050a  f7fffffe          BL       vPortEnterCritical
;;;1064   		{
;;;1065   			/* If null is passed in here then we are changing the
;;;1066   			priority of the calling function. */
;;;1067   			pxTCB = prvGetTCBFromHandle( xTask );
00050e  2c00              CMP      r4,#0
000510  bf04              ITT      EQ
000512  48eb              LDREQ    r0,|L1.2240|
000514  6804              LDREQ    r4,[r0,#0]  ; pxCurrentTCB
;;;1068   			uxReturn = pxTCB->uxPriority;
000516  6ae4              LDR      r4,[r4,#0x2c]
;;;1069   		}
;;;1070   		taskEXIT_CRITICAL();
000518  f7fffffe          BL       vPortExitCritical
;;;1071   
;;;1072   		return uxReturn;
00051c  4620              MOV      r0,r4
;;;1073   	}
00051e  bd10              POP      {r4,pc}
;;;1074   
                          ENDP

                  uxTaskPriorityGetFromISR PROC
;;;1079   
;;;1080   	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
000520  b510              PUSH     {r4,lr}
;;;1081   	{
000522  4604              MOV      r4,r0
;;;1082   	TCB_t *pxTCB;
;;;1083   	UBaseType_t uxReturn, uxSavedInterruptState;
;;;1084   
;;;1085   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1086   		maximum	system call (or maximum API call) interrupt priority.
;;;1087   		Interrupts that are	above the maximum system call priority are keep
;;;1088   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1089   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1090   		is defined in FreeRTOSConfig.h then
;;;1091   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1092   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1093   		been assigned a priority above the configured maximum system call
;;;1094   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1095   		from interrupts	that have been assigned a priority at or (logically)
;;;1096   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1097   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1098   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1099   		provided on the following link:
;;;1100   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1101   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1102   
;;;1103   		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
000524  f7fffffe          BL       ulPortSetInterruptMask
;;;1104   		{
;;;1105   			/* If null is passed in here then it is the priority of the calling
;;;1106   			task that is being queried. */
;;;1107   			pxTCB = prvGetTCBFromHandle( xTask );
000528  2c00              CMP      r4,#0
00052a  bf04              ITT      EQ
00052c  49e4              LDREQ    r1,|L1.2240|
00052e  680c              LDREQ    r4,[r1,#0]  ; pxCurrentTCB
;;;1108   			uxReturn = pxTCB->uxPriority;
000530  6ae4              LDR      r4,[r4,#0x2c]
;;;1109   		}
;;;1110   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
000532  f7fffffe          BL       vPortClearInterruptMask
;;;1111   
;;;1112   		return uxReturn;
000536  4620              MOV      r0,r4
;;;1113   	}
000538  bd10              POP      {r4,pc}
;;;1114   
                          ENDP

                  vTaskPrioritySet PROC
;;;1119   
;;;1120   	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
00053a  e92d41f0          PUSH     {r4-r8,lr}
;;;1121   	{
00053e  460e              MOV      r6,r1
000540  4604              MOV      r4,r0
;;;1122   	TCB_t *pxTCB;
;;;1123   	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;1124   	BaseType_t xYieldRequired = pdFALSE;
000542  f04f0800          MOV      r8,#0
;;;1125   
;;;1126   		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
;;;1127   
;;;1128   		/* Ensure the new priority is valid. */
;;;1129   		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
000546  2905              CMP      r1,#5
;;;1130   		{
;;;1131   			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000548  bf28              IT       CS
00054a  2604              MOVCS    r6,#4
;;;1132   		}
;;;1133   		else
;;;1134   		{
;;;1135   			mtCOVERAGE_TEST_MARKER();
;;;1136   		}
;;;1137   
;;;1138   		taskENTER_CRITICAL();
00054c  f7fffffe          BL       vPortEnterCritical
;;;1139   		{
;;;1140   			/* If null is passed in here then it is the priority of the calling
;;;1141   			task that is being changed. */
;;;1142   			pxTCB = prvGetTCBFromHandle( xTask );
000550  4ddb              LDR      r5,|L1.2240|
000552  2c00              CMP      r4,#0
000554  bf08              IT       EQ
000556  682c              LDREQ    r4,[r5,#0]  ; pxCurrentTCB
;;;1143   
;;;1144   			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;1145   
;;;1146   			#if ( configUSE_MUTEXES == 1 )
;;;1147   			{
;;;1148   				uxCurrentBasePriority = pxTCB->uxBasePriority;
;;;1149   			}
;;;1150   			#else
;;;1151   			{
;;;1152   				uxCurrentBasePriority = pxTCB->uxPriority;
;;;1153   			}
;;;1154   			#endif
;;;1155   
;;;1156   			if( uxCurrentBasePriority != uxNewPriority )
000558  6c60              LDR      r0,[r4,#0x44]
00055a  42b0              CMP      r0,r6
00055c  d03d              BEQ      |L1.1498|
;;;1157   			{
;;;1158   				/* The priority change may have readied a task of higher
;;;1159   				priority than the calling task. */
;;;1160   				if( uxNewPriority > uxCurrentBasePriority )
;;;1161   				{
;;;1162   					if( pxTCB != pxCurrentTCB )
;;;1163   					{
;;;1164   						/* The priority of a task other than the currently
;;;1165   						running task is being raised.  Is the priority being
;;;1166   						raised above that of the running task? */
;;;1167   						if( uxNewPriority >= pxCurrentTCB->uxPriority )
;;;1168   						{
;;;1169   							xYieldRequired = pdTRUE;
;;;1170   						}
;;;1171   						else
;;;1172   						{
;;;1173   							mtCOVERAGE_TEST_MARKER();
;;;1174   						}
;;;1175   					}
;;;1176   					else
;;;1177   					{
;;;1178   						/* The priority of the running task is being raised,
;;;1179   						but the running task must already be the highest
;;;1180   						priority task able to run so no yield is required. */
;;;1181   					}
;;;1182   				}
;;;1183   				else if( pxTCB == pxCurrentTCB )
00055e  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000560  4286              CMP      r6,r0                 ;1160
000562  d906              BLS      |L1.1394|
000564  428c              CMP      r4,r1                 ;1162
000566  d008              BEQ      |L1.1402|
000568  6829              LDR      r1,[r5,#0]            ;1167  ; pxCurrentTCB
00056a  6ac9              LDR      r1,[r1,#0x2c]         ;1167
00056c  42b1              CMP      r1,r6                 ;1167
00056e  d902              BLS      |L1.1398|
000570  e003              B        |L1.1402|
                  |L1.1394|
000572  428c              CMP      r4,r1
000574  d101              BNE      |L1.1402|
                  |L1.1398|
;;;1184   				{
;;;1185   					/* Setting the priority of the running task down means
;;;1186   					there may now be another task of higher priority that
;;;1187   					is ready to execute. */
;;;1188   					xYieldRequired = pdTRUE;
000576  f04f0801          MOV      r8,#1
                  |L1.1402|
;;;1189   				}
;;;1190   				else
;;;1191   				{
;;;1192   					/* Setting the priority of any other task down does not
;;;1193   					require a yield as the running task must be above the
;;;1194   					new priority of the task being modified. */
;;;1195   				}
;;;1196   
;;;1197   				/* Remember the ready list the task might be referenced from
;;;1198   				before its uxPriority member is changed so the
;;;1199   				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;1200   				uxPriorityUsedOnEntry = pxTCB->uxPriority;
;;;1201   
;;;1202   				#if ( configUSE_MUTEXES == 1 )
;;;1203   				{
;;;1204   					/* Only change the priority being used if the task is not
;;;1205   					currently using an inherited priority. */
;;;1206   					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
00057a  6ae7              LDR      r7,[r4,#0x2c]
00057c  42b8              CMP      r0,r7
;;;1207   					{
;;;1208   						pxTCB->uxPriority = uxNewPriority;
00057e  bf08              IT       EQ
000580  62e6              STREQ    r6,[r4,#0x2c]
;;;1209   					}
;;;1210   					else
;;;1211   					{
;;;1212   						mtCOVERAGE_TEST_MARKER();
;;;1213   					}
;;;1214   
;;;1215   					/* The base priority gets set whatever. */
;;;1216   					pxTCB->uxBasePriority = uxNewPriority;
;;;1217   				}
;;;1218   				#else
;;;1219   				{
;;;1220   					pxTCB->uxPriority = uxNewPriority;
;;;1221   				}
;;;1222   				#endif
;;;1223   
;;;1224   				/* Only reset the event list item value if the value is not
;;;1225   				being used for anything else. */
;;;1226   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000582  6466              STR      r6,[r4,#0x44]
000584  69a0              LDR      r0,[r4,#0x18]
000586  f0104f00          TST      r0,#0x80000000
;;;1227   				{
;;;1228   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00058a  bf04              ITT      EQ
00058c  f1c60005          RSBEQ    r0,r6,#5
000590  61a0              STREQ    r0,[r4,#0x18]
;;;1229   				}
;;;1230   				else
;;;1231   				{
;;;1232   					mtCOVERAGE_TEST_MARKER();
;;;1233   				}
;;;1234   
;;;1235   				/* If the task is in the blocked or suspended list we need do
;;;1236   				nothing more than change it's priority variable. However, if
;;;1237   				the task is in a ready list it needs to be removed and placed
;;;1238   				in the list appropriate to its new priority. */
;;;1239   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
000592  eb070187          ADD      r1,r7,r7,LSL #2
000596  4ecb              LDR      r6,|L1.2244|
000598  6960              LDR      r0,[r4,#0x14]
00059a  eb060181          ADD      r1,r6,r1,LSL #2
00059e  4288              CMP      r0,r1
0005a0  d116              BNE      |L1.1488|
;;;1240   				{
;;;1241   					/* The task is currently in its ready list - remove before adding
;;;1242   					it to it's new ready list.  As we are in a critical section we
;;;1243   					can do this even if the scheduler is suspended. */
;;;1244   					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
0005a2  1d20              ADDS     r0,r4,#4
0005a4  f7fffffe          BL       uxListRemove
0005a8  2101              MOVS     r1,#1                 ;1169
0005aa  b928              CBNZ     r0,|L1.1464|
;;;1245   					{
;;;1246   						/* It is known that the task is in its ready list so
;;;1247   						there is no need to check again and the port level
;;;1248   						reset macro can be called directly. */
;;;1249   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
0005ac  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
0005ae  fa01f007          LSL      r0,r1,r7
0005b2  ea220000          BIC      r0,r2,r0
0005b6  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L1.1464|
;;;1250   					}
;;;1251   					else
;;;1252   					{
;;;1253   						mtCOVERAGE_TEST_MARKER();
;;;1254   					}
;;;1255   					prvAddTaskToReadyList( pxTCB );
0005b8  6ae0              LDR      r0,[r4,#0x2c]
0005ba  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
0005bc  4081              LSLS     r1,r1,r0
0005be  4311              ORRS     r1,r1,r2
0005c0  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
0005c2  eb000080          ADD      r0,r0,r0,LSL #2
0005c6  eb060080          ADD      r0,r6,r0,LSL #2
0005ca  1d21              ADDS     r1,r4,#4
0005cc  f7fffffe          BL       vListInsertEnd
                  |L1.1488|
;;;1256   				}
;;;1257   				else
;;;1258   				{
;;;1259   					mtCOVERAGE_TEST_MARKER();
;;;1260   				}
;;;1261   
;;;1262   				if( xYieldRequired == pdTRUE )
0005d0  f1b80f00          CMP      r8,#0
;;;1263   				{
;;;1264   					taskYIELD_IF_USING_PREEMPTION();
0005d4  bf18              IT       NE
0005d6  f7fffffe          BLNE     vPortYield
                  |L1.1498|
;;;1265   				}
;;;1266   				else
;;;1267   				{
;;;1268   					mtCOVERAGE_TEST_MARKER();
;;;1269   				}
;;;1270   
;;;1271   				/* Remove compiler warning about unused variables when the port
;;;1272   				optimised task selection is not being used. */
;;;1273   				( void ) uxPriorityUsedOnEntry;
;;;1274   			}
;;;1275   		}
;;;1276   		taskEXIT_CRITICAL();
0005da  e8bd41f0          POP      {r4-r8,lr}
0005de  f7ffbffe          B.W      vPortExitCritical
;;;1277   	}
;;;1278   
                          ENDP

                  vTaskSwitchContext PROC
;;;2201   
;;;2202   void vTaskSwitchContext( void )
0005e2  48b7              LDR      r0,|L1.2240|
;;;2203   {
;;;2204   	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
0005e4  6ac1              LDR      r1,[r0,#0x2c]  ; uxSchedulerSuspended
0005e6  2900              CMP      r1,#0
;;;2205   	{
;;;2206   		/* The scheduler is currently suspended - do not allow a context
;;;2207   		switch. */
;;;2208   		xYieldPending = pdTRUE;
0005e8  bf1e              ITTT     NE
0005ea  2101              MOVNE    r1,#1
0005ec  61c1              STRNE    r1,[r0,#0x1c]  ; xYieldPending
;;;2209   	}
;;;2210   	else
;;;2211   	{
;;;2212   		xYieldPending = pdFALSE;
;;;2213   		traceTASK_SWITCHED_OUT();
;;;2214   
;;;2215   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2216   		{
;;;2217   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2218   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;2219   				#else
;;;2220   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2221   				#endif
;;;2222   
;;;2223   				/* Add the amount of time the task has been running to the
;;;2224   				accumulated	time so far.  The time the task started running was
;;;2225   				stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;2226   				protection here	so count values are only valid until the timer
;;;2227   				overflows.  The guard against negative values is to protect
;;;2228   				against suspect run time stat counter implementations - which
;;;2229   				are provided by the application, not the kernel. */
;;;2230   				if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;2231   				{
;;;2232   					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;2233   				}
;;;2234   				else
;;;2235   				{
;;;2236   					mtCOVERAGE_TEST_MARKER();
;;;2237   				}
;;;2238   				ulTaskSwitchedInTime = ulTotalRunTime;
;;;2239   		}
;;;2240   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;2241   
;;;2242   		/* Check for stack overflow, if configured. */
;;;2243   		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
;;;2244   		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
;;;2245   
;;;2246   		/* Select a new task to run using either the generic C or port
;;;2247   		optimised asm code. */
;;;2248   		taskSELECT_HIGHEST_PRIORITY_TASK();
;;;2249   		traceTASK_SWITCHED_IN();
;;;2250   
;;;2251   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2252   		{
;;;2253   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2254   			structure specific to this task. */
;;;2255   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2256   		}
;;;2257   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2258   	}
;;;2259   }
0005ee  4770              BXNE     lr
0005f0  2100              MOVS     r1,#0                 ;2212
0005f2  61c1              STR      r1,[r0,#0x1c]         ;2212  ; xYieldPending
0005f4  6901              LDR      r1,[r0,#0x10]         ;2248  ; uxTopReadyPriority
0005f6  4ab3              LDR      r2,|L1.2244|
0005f8  fab1f181          CLZ      r1,r1                 ;2248
0005fc  f1c1011f          RSB      r1,r1,#0x1f           ;2248
000600  eb010181          ADD      r1,r1,r1,LSL #2       ;2248
000604  eb020181          ADD      r1,r2,r1,LSL #2       ;2248
000608  f1010308          ADD      r3,r1,#8              ;2248
00060c  684a              LDR      r2,[r1,#4]            ;2248
00060e  6852              LDR      r2,[r2,#4]            ;2248
000610  604a              STR      r2,[r1,#4]            ;2248
000612  429a              CMP      r2,r3                 ;2248
000614  bf04              ITT      EQ                    ;2248
000616  6852              LDREQ    r2,[r2,#4]            ;2248
000618  604a              STREQ    r2,[r1,#4]            ;2248
00061a  68d1              LDR      r1,[r2,#0xc]          ;2248
00061c  6001              STR      r1,[r0,#0]            ;2248  ; pxCurrentTCB
00061e  4770              BX       lr
;;;2260   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSuspend PROC
;;;1283   
;;;1284   	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
000620  e92d41f0          PUSH     {r4-r8,lr}
;;;1285   	{
000624  4605              MOV      r5,r0
;;;1286   	TCB_t *pxTCB;
;;;1287   
;;;1288   		taskENTER_CRITICAL();
000626  f7fffffe          BL       vPortEnterCritical
;;;1289   		{
;;;1290   			/* If null is passed in here then it is the running task that is
;;;1291   			being suspended. */
;;;1292   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
00062a  4ca5              LDR      r4,|L1.2240|
00062c  2d00              CMP      r5,#0
00062e  bf08              IT       EQ
000630  6825              LDREQ    r5,[r4,#0]  ; pxCurrentTCB
;;;1293   
;;;1294   			traceTASK_SUSPEND( pxTCB );
;;;1295   
;;;1296   			/* Remove task from the ready/delayed list and place in the
;;;1297   			suspended list. */
;;;1298   			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000632  1d28              ADDS     r0,r5,#4
000634  f7fffffe          BL       uxListRemove
;;;1299   			{
;;;1300   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000638  4ea2              LDR      r6,|L1.2244|
00063a  2701              MOVS     r7,#1
00063c  b958              CBNZ     r0,|L1.1622|
00063e  6ae8              LDR      r0,[r5,#0x2c]
000640  eb000180          ADD      r1,r0,r0,LSL #2
000644  f8561021          LDR      r1,[r6,r1,LSL #2]
000648  b929              CBNZ     r1,|L1.1622|
00064a  6921              LDR      r1,[r4,#0x10]  ; uxTopReadyPriority
00064c  fa07f000          LSL      r0,r7,r0
000650  ea210000          BIC      r0,r1,r0
000654  6120              STR      r0,[r4,#0x10]  ; uxTopReadyPriority
                  |L1.1622|
;;;1301   			}
;;;1302   			else
;;;1303   			{
;;;1304   				mtCOVERAGE_TEST_MARKER();
;;;1305   			}
;;;1306   
;;;1307   			/* Is the task waiting on an event also? */
;;;1308   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000656  6aa8              LDR      r0,[r5,#0x28]
000658  2800              CMP      r0,#0
;;;1309   			{
;;;1310   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00065a  bf1c              ITT      NE
00065c  f1050018          ADDNE    r0,r5,#0x18
000660  f7fffffe          BLNE     uxListRemove
;;;1311   			}
;;;1312   			else
;;;1313   			{
;;;1314   				mtCOVERAGE_TEST_MARKER();
;;;1315   			}
;;;1316   
;;;1317   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
000664  1d29              ADDS     r1,r5,#4
000666  4898              LDR      r0,|L1.2248|
000668  f7fffffe          BL       vListInsertEnd
;;;1318   		}
;;;1319   		taskEXIT_CRITICAL();
00066c  f7fffffe          BL       vPortExitCritical
;;;1320   
;;;1321   		if( pxTCB == pxCurrentTCB )
000670  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000672  4285              CMP      r5,r0
;;;1322   		{
;;;1323   			if( xSchedulerRunning != pdFALSE )
;;;1324   			{
;;;1325   				/* The current task has just been suspended. */
;;;1326   				configASSERT( uxSchedulerSuspended == 0 );
;;;1327   				portYIELD_WITHIN_API();
;;;1328   			}
;;;1329   			else
;;;1330   			{
;;;1331   				/* The scheduler is not running, but the task that was pointed
;;;1332   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1333   				must be adjusted to point to a different task. */
;;;1334   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
;;;1335   				{
;;;1336   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1337   					NULL so when the next task is created pxCurrentTCB will
;;;1338   					be set to point to it no matter what its relative priority
;;;1339   					is. */
;;;1340   					pxCurrentTCB = NULL;
;;;1341   				}
;;;1342   				else
;;;1343   				{
;;;1344   					vTaskSwitchContext();
;;;1345   				}
;;;1346   			}
;;;1347   		}
;;;1348   		else
;;;1349   		{
;;;1350   			if( xSchedulerRunning != pdFALSE )
000674  6960              LDR      r0,[r4,#0x14]  ; xSchedulerRunning
000676  d12a              BNE      |L1.1742|
000678  b118              CBZ      r0,|L1.1666|
00067a  e8bd41f0          POP      {r4-r8,lr}            ;1327
00067e  f7ffbffe          B.W      vPortYield
                  |L1.1666|
000682  4891              LDR      r0,|L1.2248|
000684  68a2              LDR      r2,[r4,#8]            ;1334  ; uxCurrentNumberOfTasks
000686  6801              LDR      r1,[r0,#0]            ;1334  ; xSuspendedTaskList
000688  2000              MOVS     r0,#0                 ;1334
00068a  4291              CMP      r1,r2                 ;1334
00068c  bf04              ITT      EQ                    ;1340
00068e  6020              STREQ    r0,[r4,#0]            ;1340  ; pxCurrentTCB
;;;1351   			{
;;;1352   				/* A task other than the currently running task was suspended,
;;;1353   				reset the next expected unblock time in case it referred to the
;;;1354   				task that is now in the Suspended state. */
;;;1355   				taskENTER_CRITICAL();
;;;1356   				{
;;;1357   					prvResetNextTaskUnblockTime();
;;;1358   				}
;;;1359   				taskEXIT_CRITICAL();
;;;1360   			}
;;;1361   			else
;;;1362   			{
;;;1363   				mtCOVERAGE_TEST_MARKER();
;;;1364   			}
;;;1365   		}
;;;1366   	}
000690  e8bd81f0          POPEQ    {r4-r8,pc}
000694  6ae1              LDR      r1,[r4,#0x2c]  ; uxSchedulerSuspended
000696  2900              CMP      r1,#0
000698  bf1c              ITT      NE
00069a  61e7              STRNE    r7,[r4,#0x1c]  ; xYieldPending
00069c  e8bd81f0          POPNE    {r4-r8,pc}
0006a0  61e0              STR      r0,[r4,#0x1c]  ; xYieldPending
0006a2  6920              LDR      r0,[r4,#0x10]  ; uxTopReadyPriority
0006a4  fab0f080          CLZ      r0,r0
0006a8  f1c0001f          RSB      r0,r0,#0x1f
0006ac  eb000080          ADD      r0,r0,r0,LSL #2
0006b0  eb060080          ADD      r0,r6,r0,LSL #2
0006b4  f1000208          ADD      r2,r0,#8
0006b8  6841              LDR      r1,[r0,#4]
0006ba  6849              LDR      r1,[r1,#4]
0006bc  6041              STR      r1,[r0,#4]
0006be  4291              CMP      r1,r2
0006c0  bf04              ITT      EQ
0006c2  6849              LDREQ    r1,[r1,#4]
0006c4  6041              STREQ    r1,[r0,#4]
0006c6  68c8              LDR      r0,[r1,#0xc]
0006c8  6020              STR      r0,[r4,#0]  ; pxCurrentTCB
0006ca  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1742|
0006ce  2800              CMP      r0,#0                 ;1350
0006d0  bf08              IT       EQ
0006d2  e8bd81f0          POPEQ    {r4-r8,pc}
0006d6  f7fffffe          BL       vPortEnterCritical
0006da  6b20              LDR      r0,[r4,#0x30]         ;1355  ; pxDelayedTaskList
0006dc  6800              LDR      r0,[r0,#0]            ;1355
0006de  2800              CMP      r0,#0                 ;1355
0006e0  bf0f              ITEEE    EQ                    ;1355
0006e2  f04f30ff          MOVEQ    r0,#0xffffffff        ;1355
0006e6  6b20              LDRNE    r0,[r4,#0x30]         ;1355  ; pxDelayedTaskList
0006e8  68c0              LDRNE    r0,[r0,#0xc]          ;1355
0006ea  68c0              LDRNE    r0,[r0,#0xc]          ;1355
0006ec  bf18              IT       NE                    ;1355
0006ee  6840              LDRNE    r0,[r0,#4]            ;1355
0006f0  62a0              STR      r0,[r4,#0x28]         ;1355  ; xNextTaskUnblockTime
0006f2  e8bd41f0          POP      {r4-r8,lr}            ;1359
0006f6  f7ffbffe          B.W      vPortExitCritical
;;;1367   
                          ENDP

                  vTaskResume PROC
;;;1418   
;;;1419   	void vTaskResume( TaskHandle_t xTaskToResume )
0006fa  b570              PUSH     {r4-r6,lr}
;;;1420   	{
;;;1421   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
0006fc  0004              MOVS     r4,r0
;;;1422   
;;;1423   		/* It does not make sense to resume the calling task. */
;;;1424   		configASSERT( xTaskToResume );
;;;1425   
;;;1426   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1427   		currently executing task. */
;;;1428   		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
;;;1429   		{
;;;1430   			taskENTER_CRITICAL();
;;;1431   			{
;;;1432   				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
;;;1433   				{
;;;1434   					traceTASK_RESUME( pxTCB );
;;;1435   
;;;1436   					/* As we are in a critical section we can access the ready
;;;1437   					lists even if the scheduler is suspended. */
;;;1438   					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
;;;1439   					prvAddTaskToReadyList( pxTCB );
;;;1440   
;;;1441   					/* We may have just resumed a higher priority task. */
;;;1442   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;1443   					{
;;;1444   						/* This yield may not cause the task just resumed to run,
;;;1445   						but will leave the lists in the correct state for the
;;;1446   						next yield. */
;;;1447   						taskYIELD_IF_USING_PREEMPTION();
;;;1448   					}
;;;1449   					else
;;;1450   					{
;;;1451   						mtCOVERAGE_TEST_MARKER();
;;;1452   					}
;;;1453   				}
;;;1454   				else
;;;1455   				{
;;;1456   					mtCOVERAGE_TEST_MARKER();
;;;1457   				}
;;;1458   			}
;;;1459   			taskEXIT_CRITICAL();
;;;1460   		}
;;;1461   		else
;;;1462   		{
;;;1463   			mtCOVERAGE_TEST_MARKER();
;;;1464   		}
;;;1465   	}
0006fe  bf08              IT       EQ
000700  bd70              POPEQ    {r4-r6,pc}
000702  4d6f              LDR      r5,|L1.2240|
000704  6828              LDR      r0,[r5,#0]            ;1428  ; pxCurrentTCB
000706  4284              CMP      r4,r0                 ;1428
000708  bf08              IT       EQ
00070a  bd70              POPEQ    {r4-r6,pc}
00070c  f7fffffe          BL       vPortEnterCritical
000710  496d              LDR      r1,|L1.2248|
000712  6960              LDR      r0,[r4,#0x14]         ;1430
000714  4288              CMP      r0,r1                 ;1430
000716  d11c              BNE      |L1.1874|
000718  6aa0              LDR      r0,[r4,#0x28]         ;1430
00071a  3928              SUBS     r1,r1,#0x28           ;1430
00071c  4288              CMP      r0,r1                 ;1430
00071e  d018              BEQ      |L1.1874|
000720  b9b8              CBNZ     r0,|L1.1874|
000722  1d20              ADDS     r0,r4,#4              ;1438
000724  f7fffffe          BL       uxListRemove
000728  6ae0              LDR      r0,[r4,#0x2c]         ;1439
00072a  2101              MOVS     r1,#1                 ;1439
00072c  692a              LDR      r2,[r5,#0x10]         ;1439  ; uxTopReadyPriority
00072e  4081              LSLS     r1,r1,r0              ;1439
000730  4311              ORRS     r1,r1,r2              ;1439
000732  6129              STR      r1,[r5,#0x10]         ;1439  ; uxTopReadyPriority
000734  4963              LDR      r1,|L1.2244|
000736  eb000080          ADD      r0,r0,r0,LSL #2       ;1439
00073a  eb010080          ADD      r0,r1,r0,LSL #2       ;1439
00073e  1d21              ADDS     r1,r4,#4              ;1439
000740  f7fffffe          BL       vListInsertEnd
000744  6ae0              LDR      r0,[r4,#0x2c]         ;1442
000746  6829              LDR      r1,[r5,#0]            ;1442  ; pxCurrentTCB
000748  6ac9              LDR      r1,[r1,#0x2c]         ;1442
00074a  4288              CMP      r0,r1                 ;1442
00074c  bf28              IT       CS                    ;1447
00074e  f7fffffe          BLCS     vPortYield
                  |L1.1874|
000752  e8bd4070          POP      {r4-r6,lr}            ;1459
000756  f7ffbffe          B.W      vPortExitCritical
;;;1466   
                          ENDP

                  xTaskResumeFromISR PROC
;;;1472   
;;;1473   	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
00075a  e92d41f0          PUSH     {r4-r8,lr}
;;;1474   	{
;;;1475   	BaseType_t xYieldRequired = pdFALSE;
00075e  2500              MOVS     r5,#0
;;;1476   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
000760  4604              MOV      r4,r0
;;;1477   	UBaseType_t uxSavedInterruptStatus;
;;;1478   
;;;1479   		configASSERT( xTaskToResume );
;;;1480   
;;;1481   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1482   		maximum	system call (or maximum API call) interrupt priority.
;;;1483   		Interrupts that are	above the maximum system call priority are keep
;;;1484   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1485   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1486   		is defined in FreeRTOSConfig.h then
;;;1487   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1488   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1489   		been assigned a priority above the configured maximum system call
;;;1490   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1491   		from interrupts	that have been assigned a priority at or (logically)
;;;1492   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1493   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1494   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1495   		provided on the following link:
;;;1496   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1497   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1498   
;;;1499   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000762  f7fffffe          BL       ulPortSetInterruptMask
000766  4a58              LDR      r2,|L1.2248|
000768  6961              LDR      r1,[r4,#0x14]
00076a  4606              MOV      r6,r0
00076c  4291              CMP      r1,r2
00076e  d124              BNE      |L1.1978|
000770  6aa0              LDR      r0,[r4,#0x28]
000772  f1a20128          SUB      r1,r2,#0x28
000776  4288              CMP      r0,r1
000778  d01f              BEQ      |L1.1978|
00077a  b9f0              CBNZ     r0,|L1.1978|
;;;1500   		{
;;;1501   			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
;;;1502   			{
;;;1503   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1504   
;;;1505   				/* Check the ready lists can be accessed. */
;;;1506   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00077c  4f50              LDR      r7,|L1.2240|
00077e  6af8              LDR      r0,[r7,#0x2c]  ; uxSchedulerSuspended
000780  2800              CMP      r0,#0
;;;1507   				{
;;;1508   					/* Ready lists can be accessed so move the task from the
;;;1509   					suspended list to the ready list directly. */
;;;1510   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;1511   					{
;;;1512   						xYieldRequired = pdTRUE;
;;;1513   					}
;;;1514   					else
;;;1515   					{
;;;1516   						mtCOVERAGE_TEST_MARKER();
;;;1517   					}
;;;1518   
;;;1519   					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
;;;1520   					prvAddTaskToReadyList( pxTCB );
;;;1521   				}
;;;1522   				else
;;;1523   				{
;;;1524   					/* The delayed or ready lists cannot be accessed so the task
;;;1525   					is held in the pending ready list until the scheduler is
;;;1526   					unsuspended. */
;;;1527   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000782  bf1c              ITT      NE
000784  f1040118          ADDNE    r1,r4,#0x18
000788  4850              LDRNE    r0,|L1.2252|
00078a  d114              BNE      |L1.1974|
00078c  6ae0              LDR      r0,[r4,#0x2c]         ;1510
00078e  6839              LDR      r1,[r7,#0]            ;1510  ; pxCurrentTCB
000790  6ac9              LDR      r1,[r1,#0x2c]         ;1510
000792  4288              CMP      r0,r1                 ;1510
000794  bf28              IT       CS                    ;1512
000796  2501              MOVCS    r5,#1                 ;1512
000798  1d20              ADDS     r0,r4,#4              ;1519
00079a  f7fffffe          BL       uxListRemove
00079e  6ae0              LDR      r0,[r4,#0x2c]         ;1520
0007a0  2101              MOVS     r1,#1                 ;1520
0007a2  693a              LDR      r2,[r7,#0x10]         ;1520  ; uxTopReadyPriority
0007a4  4081              LSLS     r1,r1,r0              ;1520
0007a6  4311              ORRS     r1,r1,r2              ;1520
0007a8  6139              STR      r1,[r7,#0x10]         ;1520  ; uxTopReadyPriority
0007aa  4946              LDR      r1,|L1.2244|
0007ac  eb000080          ADD      r0,r0,r0,LSL #2       ;1520
0007b0  eb010080          ADD      r0,r1,r0,LSL #2       ;1520
0007b4  1d21              ADDS     r1,r4,#4              ;1520
                  |L1.1974|
0007b6  f7fffffe          BL       vListInsertEnd
                  |L1.1978|
;;;1528   				}
;;;1529   			}
;;;1530   			else
;;;1531   			{
;;;1532   				mtCOVERAGE_TEST_MARKER();
;;;1533   			}
;;;1534   		}
;;;1535   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0007ba  4630              MOV      r0,r6
0007bc  f7fffffe          BL       vPortClearInterruptMask
;;;1536   
;;;1537   		return xYieldRequired;
0007c0  4628              MOV      r0,r5
;;;1538   	}
0007c2  e8bd81f0          POP      {r4-r8,pc}
;;;1539   
                          ENDP

                  prvIdleTask PROC
;;;2657    */
;;;2658   static portTASK_FUNCTION( prvIdleTask, pvParameters )
0007c6  4e42              LDR      r6,|L1.2256|
0007c8  4c3d              LDR      r4,|L1.2240|
;;;2659   {
;;;2660   	/* Stop warnings. */
;;;2661   	( void ) pvParameters;
;;;2662   
;;;2663   	for( ;; )
;;;2664   	{
;;;2665   		/* See if any tasks have been deleted. */
;;;2666   		prvCheckTasksWaitingTermination();
;;;2667   
;;;2668   		#if ( configUSE_PREEMPTION == 0 )
;;;2669   		{
;;;2670   			/* If we are not using preemption we keep forcing a task switch to
;;;2671   			see if any other task has become available.  If we are using
;;;2672   			preemption we don't need to do this as any task becoming available
;;;2673   			will automatically get the processor anyway. */
;;;2674   			taskYIELD();
;;;2675   		}
;;;2676   		#endif /* configUSE_PREEMPTION */
;;;2677   
;;;2678   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;2679   		{
;;;2680   			/* When using preemption tasks of equal priority will be
;;;2681   			timesliced.  If a task that is sharing the idle priority is ready
;;;2682   			to run then the idle task should yield before the end of the
;;;2683   			timeslice.
;;;2684   
;;;2685   			A critical region is not required here as we are just reading from
;;;2686   			the list, and an occasional incorrect value will not matter.  If
;;;2687   			the ready list at the idle priority contains more than one task
;;;2688   			then a task other than the idle task is ready to execute. */
;;;2689   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
0007ca  f1a607a0          SUB      r7,r6,#0xa0
                  |L1.1998|
0007ce  6860              LDR      r0,[r4,#4]  ; uxTasksDeleted
0007d0  b1f0              CBZ      r0,|L1.2064|
                  |L1.2002|
0007d2  6ae0              LDR      r0,[r4,#0x2c]  ; uxSchedulerSuspended
0007d4  1c40              ADDS     r0,r0,#1
0007d6  62e0              STR      r0,[r4,#0x2c]  ; uxSchedulerSuspended
0007d8  6830              LDR      r0,[r6,#0]  ; xTasksWaitingTermination
0007da  b1f8              CBZ      r0,|L1.2076|
0007dc  f7fffffe          BL       xTaskResumeAll
0007e0  f7fffffe          BL       vPortEnterCritical
0007e4  68f0              LDR      r0,[r6,#0xc]  ; xTasksWaitingTermination
0007e6  68c5              LDR      r5,[r0,#0xc]
0007e8  1d28              ADDS     r0,r5,#4
0007ea  f7fffffe          BL       uxListRemove
0007ee  68a0              LDR      r0,[r4,#8]  ; uxCurrentNumberOfTasks
0007f0  1e40              SUBS     r0,r0,#1
0007f2  60a0              STR      r0,[r4,#8]  ; uxCurrentNumberOfTasks
0007f4  6860              LDR      r0,[r4,#4]  ; uxTasksDeleted
0007f6  1e40              SUBS     r0,r0,#1
0007f8  6060              STR      r0,[r4,#4]  ; uxTasksDeleted
0007fa  f7fffffe          BL       vPortExitCritical
0007fe  6b28              LDR      r0,[r5,#0x30]
000800  f7fffffe          BL       vPortFree
000804  4628              MOV      r0,r5
000806  f7fffffe          BL       vPortFree
                  |L1.2058|
00080a  6860              LDR      r0,[r4,#4]  ; uxTasksDeleted
00080c  2800              CMP      r0,#0
00080e  d1e0              BNE      |L1.2002|
                  |L1.2064|
000810  6838              LDR      r0,[r7,#0]  ; pxReadyTasksLists
000812  2801              CMP      r0,#1
;;;2690   			{
;;;2691   				taskYIELD();
000814  bf88              IT       HI
000816  f7fffffe          BLHI     vPortYield
00081a  e7d8              B        |L1.1998|
                  |L1.2076|
00081c  f7fffffe          BL       xTaskResumeAll
000820  e7f3              B        |L1.2058|
;;;2692   			}
;;;2693   			else
;;;2694   			{
;;;2695   				mtCOVERAGE_TEST_MARKER();
;;;2696   			}
;;;2697   		}
;;;2698   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;2699   
;;;2700   		#if ( configUSE_IDLE_HOOK == 1 )
;;;2701   		{
;;;2702   			extern void vApplicationIdleHook( void );
;;;2703   
;;;2704   			/* Call the user defined function from within the idle task.  This
;;;2705   			allows the application designer to add background functionality
;;;2706   			without the overhead of a separate task.
;;;2707   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;2708   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;2709   			vApplicationIdleHook();
;;;2710   		}
;;;2711   		#endif /* configUSE_IDLE_HOOK */
;;;2712   
;;;2713   		/* This conditional compilation should use inequality to 0, not equality
;;;2714   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;2715   		user defined low power mode	implementations require
;;;2716   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;2717   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;2718   		{
;;;2719   		TickType_t xExpectedIdleTime;
;;;2720   
;;;2721   			/* It is not desirable to suspend then resume the scheduler on
;;;2722   			each iteration of the idle task.  Therefore, a preliminary
;;;2723   			test of the expected idle time is performed without the
;;;2724   			scheduler suspended.  The result here is not necessarily
;;;2725   			valid. */
;;;2726   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2727   
;;;2728   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2729   			{
;;;2730   				vTaskSuspendAll();
;;;2731   				{
;;;2732   					/* Now the scheduler is suspended, the expected idle
;;;2733   					time can be sampled again, and this time its value can
;;;2734   					be used. */
;;;2735   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;2736   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2737   
;;;2738   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2739   					{
;;;2740   						traceLOW_POWER_IDLE_BEGIN();
;;;2741   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;2742   						traceLOW_POWER_IDLE_END();
;;;2743   					}
;;;2744   					else
;;;2745   					{
;;;2746   						mtCOVERAGE_TEST_MARKER();
;;;2747   					}
;;;2748   				}
;;;2749   				( void ) xTaskResumeAll();
;;;2750   			}
;;;2751   			else
;;;2752   			{
;;;2753   				mtCOVERAGE_TEST_MARKER();
;;;2754   			}
;;;2755   		}
;;;2756   		#endif /* configUSE_TICKLESS_IDLE */
;;;2757   	}
;;;2758   }
;;;2759   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskStartScheduler PROC
;;;1542   
;;;1543   void vTaskStartScheduler( void )
000822  b510              PUSH     {r4,lr}
;;;1544   {
000824  b084              SUB      sp,sp,#0x10
;;;1545   BaseType_t xReturn;
;;;1546   
;;;1547   	/* Add the idle task at the lowest priority. */
;;;1548   	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
;;;1549   	{
;;;1550   		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
;;;1551   		be returned by the xTaskGetIdleTaskHandle() function. */
;;;1552   		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1553   	}
;;;1554   	#else
;;;1555   	{
;;;1556   		/* Create the idle task without storing its handle. */
;;;1557   		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
000826  2400              MOVS     r4,#0
000828  9400              STR      r4,[sp,#0]
00082a  9401              STR      r4,[sp,#4]
00082c  9402              STR      r4,[sp,#8]
00082e  4623              MOV      r3,r4
000830  2280              MOVS     r2,#0x80
000832  a128              ADR      r1,|L1.2260|
000834  4829              LDR      r0,|L1.2268|
000836  9403              STR      r4,[sp,#0xc]
000838  f7fffffe          BL       xTaskGenericCreate
;;;1558   	}
;;;1559   	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
;;;1560   
;;;1561   	#if ( configUSE_TIMERS == 1 )
;;;1562   	{
;;;1563   		if( xReturn == pdPASS )
00083c  2801              CMP      r0,#1
;;;1564   		{
;;;1565   			xReturn = xTimerCreateTimerTask();
;;;1566   		}
;;;1567   		else
;;;1568   		{
;;;1569   			mtCOVERAGE_TEST_MARKER();
;;;1570   		}
;;;1571   	}
;;;1572   	#endif /* configUSE_TIMERS */
;;;1573   
;;;1574   	if( xReturn == pdPASS )
;;;1575   	{
;;;1576   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;1577   		before or during the call to xPortStartScheduler().  The stacks of
;;;1578   		the created tasks contain a status word with interrupts switched on
;;;1579   		so interrupts will automatically get re-enabled when the first task
;;;1580   		starts to run. */
;;;1581   		portDISABLE_INTERRUPTS();
;;;1582   
;;;1583   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1584   		{
;;;1585   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1586   			structure specific to the task that will run first. */
;;;1587   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1588   		}
;;;1589   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1590   
;;;1591   		xSchedulerRunning = pdTRUE;
;;;1592   		xTickCount = ( TickType_t ) 0U;
;;;1593   
;;;1594   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;1595   		macro must be defined to configure the timer/counter used to generate
;;;1596   		the run time counter time base. */
;;;1597   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;1598   
;;;1599   		/* Setting up the timer tick is hardware specific and thus in the
;;;1600   		portable interface. */
;;;1601   		if( xPortStartScheduler() != pdFALSE )
;;;1602   		{
;;;1603   			/* Should not reach here as if the scheduler is running the
;;;1604   			function will not return. */
;;;1605   		}
;;;1606   		else
;;;1607   		{
;;;1608   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;1609   		}
;;;1610   	}
;;;1611   	else
;;;1612   	{
;;;1613   		/* This line will only be reached if the kernel could not be started,
;;;1614   		because there was not enough FreeRTOS heap to create the idle task
;;;1615   		or the timer task. */
;;;1616   		configASSERT( xReturn );
;;;1617   	}
;;;1618   }
00083e  bf1c              ITT      NE
000840  b004              ADDNE    sp,sp,#0x10
000842  bd10              POPNE    {r4,pc}
000844  f7fffffe          BL       xTimerCreateTimerTask
000848  2801              CMP      r0,#1                 ;1574
00084a  bf1c              ITT      NE
00084c  b004              ADDNE    sp,sp,#0x10
00084e  bd10              POPNE    {r4,pc}
000850  f7fffffe          BL       ulPortSetInterruptMask
000854  481a              LDR      r0,|L1.2240|
000856  2101              MOVS     r1,#1                 ;1591
000858  6141              STR      r1,[r0,#0x14]         ;1591  ; xSchedulerRunning
00085a  60c4              STR      r4,[r0,#0xc]          ;1592  ; xTickCount
00085c  b004              ADD      sp,sp,#0x10           ;1601
00085e  e8bd4010          POP      {r4,lr}               ;1601
000862  f7ffbffe          B.W      xPortStartScheduler
;;;1619   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskEndScheduler PROC
;;;1620   
;;;1621   void vTaskEndScheduler( void )
000866  b510              PUSH     {r4,lr}
;;;1622   {
;;;1623   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;1624   	routine so the original ISRs can be restored if necessary.  The port
;;;1625   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;1626   	portDISABLE_INTERRUPTS();
000868  f7fffffe          BL       ulPortSetInterruptMask
;;;1627   	xSchedulerRunning = pdFALSE;
00086c  4914              LDR      r1,|L1.2240|
00086e  2000              MOVS     r0,#0
000870  6148              STR      r0,[r1,#0x14]  ; xSchedulerRunning
;;;1628   	vPortEndScheduler();
000872  e8bd4010          POP      {r4,lr}
000876  f7ffbffe          B.W      vPortEndScheduler
;;;1629   }
;;;1630   /*----------------------------------------------------------*/
                          ENDP

                  xTaskGetTickCount PROC
;;;1762   
;;;1763   TickType_t xTaskGetTickCount( void )
00087a  4811              LDR      r0,|L1.2240|
;;;1764   {
;;;1765   TickType_t xTicks;
;;;1766   
;;;1767   	/* Critical section required if running on a 16 bit processor. */
;;;1768   	portTICK_TYPE_ENTER_CRITICAL();
;;;1769   	{
;;;1770   		xTicks = xTickCount;
00087c  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
;;;1771   	}
;;;1772   	portTICK_TYPE_EXIT_CRITICAL();
;;;1773   
;;;1774   	return xTicks;
;;;1775   }
00087e  4770              BX       lr
;;;1776   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskGetTickCountFromISR PROC
;;;1777   
;;;1778   TickType_t xTaskGetTickCountFromISR( void )
000880  480f              LDR      r0,|L1.2240|
;;;1779   {
;;;1780   TickType_t xReturn;
;;;1781   UBaseType_t uxSavedInterruptStatus;
;;;1782   
;;;1783   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1784   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1785   	above the maximum system call priority are kept permanently enabled, even
;;;1786   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1787   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1788   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1789   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1790   	assigned a priority above the configured maximum system call priority.
;;;1791   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1792   	that have been assigned a priority at or (logically) below the maximum
;;;1793   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1794   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1795   	More information (albeit Cortex-M specific) is provided on the following
;;;1796   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1797   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1798   
;;;1799   	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
;;;1800   	{
;;;1801   		xReturn = xTickCount;
000882  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
;;;1802   	}
;;;1803   	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1804   
;;;1805   	return xReturn;
;;;1806   }
000884  4770              BX       lr
;;;1807   /*-----------------------------------------------------------*/
                          ENDP

                  uxTaskGetNumberOfTasks PROC
;;;1808   
;;;1809   UBaseType_t uxTaskGetNumberOfTasks( void )
000886  480e              LDR      r0,|L1.2240|
;;;1810   {
;;;1811   	/* A critical section is not required because the variables are of type
;;;1812   	BaseType_t. */
;;;1813   	return uxCurrentNumberOfTasks;
000888  6880              LDR      r0,[r0,#8]  ; uxCurrentNumberOfTasks
;;;1814   }
00088a  4770              BX       lr
;;;1815   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskPlaceOnEventList PROC
;;;2261   
;;;2262   void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
00088c  b570              PUSH     {r4-r6,lr}
;;;2263   {
;;;2264   TickType_t xTimeToWake;
;;;2265   
;;;2266   	configASSERT( pxEventList );
;;;2267   
;;;2268   	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
;;;2269   	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
;;;2270   
;;;2271   	/* Place the event list item of the TCB in the appropriate event list.
;;;2272   	This is placed in the list in priority order so the highest priority task
;;;2273   	is the first to be woken by the event.  The queue that contains the event
;;;2274   	list is locked, preventing simultaneous access from interrupts. */
;;;2275   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00088e  4c0c              LDR      r4,|L1.2240|
000890  460d              MOV      r5,r1                 ;2263
000892  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000894  3118              ADDS     r1,r1,#0x18
000896  f7fffffe          BL       vListInsert
;;;2276   
;;;2277   	/* The task must be removed from from the ready list before it is added to
;;;2278   	the blocked list as the same list item is used for both lists.  Exclusive
;;;2279   	access to the ready lists guaranteed because the scheduler is locked. */
;;;2280   	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00089a  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00089c  1d00              ADDS     r0,r0,#4
00089e  f7fffffe          BL       uxListRemove
0008a2  b948              CBNZ     r0,|L1.2232|
;;;2281   	{
;;;2282   		/* The current task must be in a ready list, so there is no need to
;;;2283   		check, and the port reset macro can be called directly. */
;;;2284   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
0008a4  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
0008a6  2101              MOVS     r1,#1
0008a8  f890002c          LDRB     r0,[r0,#0x2c]
0008ac  fa01f000          LSL      r0,r1,r0
0008b0  6921              LDR      r1,[r4,#0x10]  ; uxTopReadyPriority
0008b2  ea210000          BIC      r0,r1,r0
0008b6  6120              STR      r0,[r4,#0x10]  ; uxTopReadyPriority
                  |L1.2232|
;;;2285   	}
;;;2286   	else
;;;2287   	{
;;;2288   		mtCOVERAGE_TEST_MARKER();
;;;2289   	}
;;;2290   
;;;2291   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;2292   	{
;;;2293   		if( xTicksToWait == portMAX_DELAY )
0008b8  f1b53fff          CMP      r5,#0xffffffff
0008bc  d016              BEQ      |L1.2284|
;;;2294   		{
;;;2295   			/* Add the task to the suspended task list instead of a delayed task
;;;2296   			list to ensure the task is not woken by a timing event.  It will
;;;2297   			block indefinitely. */
;;;2298   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
;;;2299   		}
;;;2300   		else
;;;2301   		{
;;;2302   			/* Calculate the time at which the task should be woken if the event
;;;2303   			does not occur.  This may overflow but this doesn't matter, the
;;;2304   			scheduler will handle it. */
;;;2305   			xTimeToWake = xTickCount + xTicksToWait;
0008be  e00f              B        |L1.2272|
                  |L1.2240|
                          DCD      ||.data||
                  |L1.2244|
                          DCD      ||.bss||
                  |L1.2248|
                          DCD      ||.bss||+0xb4
                  |L1.2252|
                          DCD      ||.bss||+0x8c
                  |L1.2256|
                          DCD      ||.bss||+0xa0
                  |L1.2260|
0008d4  49444c45          DCB      "IDLE",0
0008d8  00      
0008d9  00                DCB      0
0008da  00                DCB      0
0008db  00                DCB      0
                  |L1.2268|
                          DCD      prvIdleTask
                  |L1.2272|
0008e0  68e0              LDR      r0,[r4,#0xc]  ; xTickCount
0008e2  4428              ADD      r0,r0,r5
;;;2306   			prvAddCurrentTaskToDelayedList( xTimeToWake );
0008e4  e8bd4070          POP      {r4-r6,lr}
0008e8  f7ffbffe          B.W      prvAddCurrentTaskToDelayedList
                  |L1.2284|
0008ec  6820              LDR      r0,[r4,#0]            ;2298  ; pxCurrentTCB
0008ee  e8bd4070          POP      {r4-r6,lr}            ;2298
0008f2  1d01              ADDS     r1,r0,#4              ;2298
0008f4  48fc              LDR      r0,|L1.3304|
0008f6  f7ffbffe          B.W      vListInsertEnd
;;;2307   		}
;;;2308   	}
;;;2309   	#else /* INCLUDE_vTaskSuspend */
;;;2310   	{
;;;2311   			/* Calculate the time at which the task should be woken if the event does
;;;2312   			not occur.  This may overflow but this doesn't matter, the scheduler
;;;2313   			will handle it. */
;;;2314   			xTimeToWake = xTickCount + xTicksToWait;
;;;2315   			prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;2316   	}
;;;2317   	#endif /* INCLUDE_vTaskSuspend */
;;;2318   }
;;;2319   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskPlaceOnUnorderedEventList PROC
;;;2320   
;;;2321   void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
0008fa  b570              PUSH     {r4-r6,lr}
;;;2322   {
;;;2323   TickType_t xTimeToWake;
;;;2324   
;;;2325   	configASSERT( pxEventList );
;;;2326   
;;;2327   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2328   	the event groups implementation. */
;;;2329   	configASSERT( uxSchedulerSuspended != 0 );
;;;2330   
;;;2331   	/* Store the item value in the event list item.  It is safe to access the
;;;2332   	event list item here as interrupts won't access the event list item of a
;;;2333   	task that is not in the Blocked state. */
;;;2334   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
0008fc  4cfb              LDR      r4,|L1.3308|
0008fe  4615              MOV      r5,r2                 ;2322
000900  f0414100          ORR      r1,r1,#0x80000000
000904  6822              LDR      r2,[r4,#0]  ; pxCurrentTCB
;;;2335   
;;;2336   	/* Place the event list item of the TCB at the end of the appropriate event
;;;2337   	list.  It is safe to access the event list here because it is part of an
;;;2338   	event group implementation - and interrupts don't access event groups
;;;2339   	directly (instead they access them indirectly by pending function calls to
;;;2340   	the task level). */
;;;2341   	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000906  6191              STR      r1,[r2,#0x18]
000908  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
00090a  3118              ADDS     r1,r1,#0x18
00090c  f7fffffe          BL       vListInsertEnd
;;;2342   
;;;2343   	/* The task must be removed from the ready list before it is added to the
;;;2344   	blocked list.  Exclusive access can be assured to the ready list as the
;;;2345   	scheduler is locked. */
;;;2346   	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000910  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000912  1d00              ADDS     r0,r0,#4
000914  f7fffffe          BL       uxListRemove
000918  b948              CBNZ     r0,|L1.2350|
;;;2347   	{
;;;2348   		/* The current task must be in a ready list, so there is no need to
;;;2349   		check, and the port reset macro can be called directly. */
;;;2350   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
00091a  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00091c  2101              MOVS     r1,#1
00091e  f890002c          LDRB     r0,[r0,#0x2c]
000922  fa01f000          LSL      r0,r1,r0
000926  6921              LDR      r1,[r4,#0x10]  ; uxTopReadyPriority
000928  ea210000          BIC      r0,r1,r0
00092c  6120              STR      r0,[r4,#0x10]  ; uxTopReadyPriority
                  |L1.2350|
;;;2351   	}
;;;2352   	else
;;;2353   	{
;;;2354   		mtCOVERAGE_TEST_MARKER();
;;;2355   	}
;;;2356   
;;;2357   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;2358   	{
;;;2359   		if( xTicksToWait == portMAX_DELAY )
00092e  f1b53fff          CMP      r5,#0xffffffff
000932  d005              BEQ      |L1.2368|
;;;2360   		{
;;;2361   			/* Add the task to the suspended task list instead of a delayed task
;;;2362   			list to ensure it is not woken by a timing event.  It will block
;;;2363   			indefinitely. */
;;;2364   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
;;;2365   		}
;;;2366   		else
;;;2367   		{
;;;2368   			/* Calculate the time at which the task should be woken if the event
;;;2369   			does not occur.  This may overflow but this doesn't matter, the
;;;2370   			kernel will manage it correctly. */
;;;2371   			xTimeToWake = xTickCount + xTicksToWait;
000934  68e0              LDR      r0,[r4,#0xc]  ; xTickCount
000936  4428              ADD      r0,r0,r5
;;;2372   			prvAddCurrentTaskToDelayedList( xTimeToWake );
000938  e8bd4070          POP      {r4-r6,lr}
00093c  f7ffbffe          B.W      prvAddCurrentTaskToDelayedList
                  |L1.2368|
000940  6820              LDR      r0,[r4,#0]            ;2364  ; pxCurrentTCB
000942  e8bd4070          POP      {r4-r6,lr}            ;2364
000946  1d01              ADDS     r1,r0,#4              ;2364
000948  48e7              LDR      r0,|L1.3304|
00094a  f7ffbffe          B.W      vListInsertEnd
;;;2373   		}
;;;2374   	}
;;;2375   	#else /* INCLUDE_vTaskSuspend */
;;;2376   	{
;;;2377   			/* Calculate the time at which the task should be woken if the event does
;;;2378   			not occur.  This may overflow but this doesn't matter, the kernel
;;;2379   			will manage it correctly. */
;;;2380   			xTimeToWake = xTickCount + xTicksToWait;
;;;2381   			prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;2382   	}
;;;2383   	#endif /* INCLUDE_vTaskSuspend */
;;;2384   }
;;;2385   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskPlaceOnEventListRestricted PROC
;;;2388   
;;;2389   	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
00094e  b570              PUSH     {r4-r6,lr}
;;;2390   	{
;;;2391   	TickType_t xTimeToWake;
;;;2392   
;;;2393   		configASSERT( pxEventList );
;;;2394   
;;;2395   		/* This function should not be called by application code hence the
;;;2396   		'Restricted' in its name.  It is not part of the public API.  It is
;;;2397   		designed for use by kernel code, and has special calling requirements -
;;;2398   		it should be called with the scheduler suspended. */
;;;2399   
;;;2400   
;;;2401   		/* Place the event list item of the TCB in the appropriate event list.
;;;2402   		In this case it is assume that this is the only task that is going to
;;;2403   		be waiting on this event list, so the faster vListInsertEnd() function
;;;2404   		can be used in place of vListInsert. */
;;;2405   		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000950  4ce6              LDR      r4,|L1.3308|
000952  460d              MOV      r5,r1                 ;2390
000954  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000956  3118              ADDS     r1,r1,#0x18
000958  f7fffffe          BL       vListInsertEnd
;;;2406   
;;;2407   		/* We must remove this task from the ready list before adding it to the
;;;2408   		blocked list as the same list item is used for both lists.  This
;;;2409   		function is called with the scheduler locked so interrupts will not
;;;2410   		access the lists at the same time. */
;;;2411   		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00095c  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00095e  1d00              ADDS     r0,r0,#4
000960  f7fffffe          BL       uxListRemove
000964  b948              CBNZ     r0,|L1.2426|
;;;2412   		{
;;;2413   			/* The current task must be in a ready list, so there is no need to
;;;2414   			check, and the port reset macro can be called directly. */
;;;2415   			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000966  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000968  2101              MOVS     r1,#1
00096a  f890002c          LDRB     r0,[r0,#0x2c]
00096e  fa01f000          LSL      r0,r1,r0
000972  6921              LDR      r1,[r4,#0x10]  ; uxTopReadyPriority
000974  ea210000          BIC      r0,r1,r0
000978  6120              STR      r0,[r4,#0x10]  ; uxTopReadyPriority
                  |L1.2426|
;;;2416   		}
;;;2417   		else
;;;2418   		{
;;;2419   			mtCOVERAGE_TEST_MARKER();
;;;2420   		}
;;;2421   
;;;2422   		/* Calculate the time at which the task should be woken if the event does
;;;2423   		not occur.  This may overflow but this doesn't matter. */
;;;2424   		xTimeToWake = xTickCount + xTicksToWait;
00097a  68e0              LDR      r0,[r4,#0xc]  ; xTickCount
00097c  4428              ADD      r0,r0,r5
;;;2425   
;;;2426   		traceTASK_DELAY_UNTIL();
;;;2427   		prvAddCurrentTaskToDelayedList( xTimeToWake );
00097e  e8bd4070          POP      {r4-r6,lr}
000982  f7ffbffe          B.W      prvAddCurrentTaskToDelayedList
;;;2428   	}
;;;2429   
                          ENDP

                  xTaskRemoveFromEventList PROC
;;;2432   
;;;2433   BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
000986  b570              PUSH     {r4-r6,lr}
;;;2434   {
;;;2435   TCB_t *pxUnblockedTCB;
;;;2436   BaseType_t xReturn;
;;;2437   
;;;2438   	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
;;;2439   	called from a critical section within an ISR. */
;;;2440   
;;;2441   	/* The event list is sorted in priority order, so the first in the list can
;;;2442   	be removed as it is known to be the highest priority.  Remove the TCB from
;;;2443   	the delayed list, and add it to the ready list.
;;;2444   
;;;2445   	If an event is for a queue that is locked then this function will never
;;;2446   	get called - the lock count on the queue will get modified instead.  This
;;;2447   	means exclusive access to the event list is guaranteed here.
;;;2448   
;;;2449   	This function assumes that a check has already been made to ensure that
;;;2450   	pxEventList is not empty. */
;;;2451   	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
000988  68c0              LDR      r0,[r0,#0xc]
;;;2452   	configASSERT( pxUnblockedTCB );
;;;2453   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
00098a  68c5              LDR      r5,[r0,#0xc]
00098c  f1050018          ADD      r0,r5,#0x18
000990  f7fffffe          BL       uxListRemove
;;;2454   
;;;2455   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000994  4cd5              LDR      r4,|L1.3308|
000996  6ae0              LDR      r0,[r4,#0x2c]  ; uxSchedulerSuspended
;;;2456   	{
;;;2457   		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
;;;2458   		prvAddTaskToReadyList( pxUnblockedTCB );
000998  2601              MOVS     r6,#1
00099a  2800              CMP      r0,#0                 ;2455
;;;2459   	}
;;;2460   	else
;;;2461   	{
;;;2462   		/* The delayed and ready lists cannot be accessed, so hold this task
;;;2463   		pending until the scheduler is resumed. */
;;;2464   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
00099c  bf1c              ITT      NE
00099e  f1050118          ADDNE    r1,r5,#0x18
0009a2  48d3              LDRNE    r0,|L1.3312|
0009a4  d00b              BEQ      |L1.2494|
0009a6  bf00              NOP      
                  |L1.2472|
0009a8  f7fffffe          BL       vListInsertEnd
;;;2465   	}
;;;2466   
;;;2467   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
0009ac  6ae8              LDR      r0,[r5,#0x2c]
0009ae  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
0009b0  6ac9              LDR      r1,[r1,#0x2c]
0009b2  4288              CMP      r0,r1
;;;2468   	{
;;;2469   		/* Return true if the task removed from the event list has a higher
;;;2470   		priority than the calling task.  This allows the calling task to know if
;;;2471   		it should force a context switch now. */
;;;2472   		xReturn = pdTRUE;
0009b4  bf86              ITTE     HI
0009b6  2001              MOVHI    r0,#1
;;;2473   
;;;2474   		/* Mark that a yield is pending in case the user is not using the
;;;2475   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2476   		xYieldPending = pdTRUE;
0009b8  61e6              STRHI    r6,[r4,#0x1c]  ; xYieldPending
;;;2477   	}
;;;2478   	else
;;;2479   	{
;;;2480   		xReturn = pdFALSE;
0009ba  2000              MOVLS    r0,#0
;;;2481   	}
;;;2482   
;;;2483   	#if( configUSE_TICKLESS_IDLE == 1 )
;;;2484   	{
;;;2485   		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
;;;2486   		might be set to the blocked task's time out time.  If the task is
;;;2487   		unblocked for a reason other than a timeout xNextTaskUnblockTime is
;;;2488   		normally left unchanged, because it is automatically get reset to a new
;;;2489   		value when the tick count equals xNextTaskUnblockTime.  However if
;;;2490   		tickless idling is used it might be more important to enter sleep mode
;;;2491   		at the earliest possible time - so reset xNextTaskUnblockTime here to
;;;2492   		ensure it is updated at the earliest possible time. */
;;;2493   		prvResetNextTaskUnblockTime();
;;;2494   	}
;;;2495   	#endif
;;;2496   
;;;2497   	return xReturn;
;;;2498   }
0009bc  bd70              POP      {r4-r6,pc}
                  |L1.2494|
0009be  1d28              ADDS     r0,r5,#4              ;2457
0009c0  f7fffffe          BL       uxListRemove
0009c4  6ae8              LDR      r0,[r5,#0x2c]         ;2458
0009c6  6922              LDR      r2,[r4,#0x10]         ;2458  ; uxTopReadyPriority
0009c8  fa06f100          LSL      r1,r6,r0              ;2458
0009cc  4311              ORRS     r1,r1,r2              ;2458
0009ce  6121              STR      r1,[r4,#0x10]         ;2458  ; uxTopReadyPriority
0009d0  49c8              LDR      r1,|L1.3316|
0009d2  eb000080          ADD      r0,r0,r0,LSL #2       ;2458
0009d6  eb010080          ADD      r0,r1,r0,LSL #2       ;2458
0009da  1d29              ADDS     r1,r5,#4              ;2458
0009dc  e7e4              B        |L1.2472|
;;;2499   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskRemoveFromUnorderedEventList PROC
;;;2500   
;;;2501   BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
0009de  b570              PUSH     {r4-r6,lr}
;;;2502   {
;;;2503   TCB_t *pxUnblockedTCB;
;;;2504   BaseType_t xReturn;
;;;2505   
;;;2506   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2507   	the event flags implementation. */
;;;2508   	configASSERT( uxSchedulerSuspended != pdFALSE );
;;;2509   
;;;2510   	/* Store the new item value in the event list. */
;;;2511   	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
0009e0  f0414100          ORR      r1,r1,#0x80000000
;;;2512   
;;;2513   	/* Remove the event list form the event flag.  Interrupts do not access
;;;2514   	event flags. */
;;;2515   	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
0009e4  6001              STR      r1,[r0,#0]
;;;2516   	configASSERT( pxUnblockedTCB );
;;;2517   	( void ) uxListRemove( pxEventListItem );
0009e6  68c5              LDR      r5,[r0,#0xc]
0009e8  f7fffffe          BL       uxListRemove
;;;2518   
;;;2519   	/* Remove the task from the delayed list and add it to the ready list.  The
;;;2520   	scheduler is suspended so interrupts will not be accessing the ready
;;;2521   	lists. */
;;;2522   	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
0009ec  1d28              ADDS     r0,r5,#4
0009ee  f7fffffe          BL       uxListRemove
;;;2523   	prvAddTaskToReadyList( pxUnblockedTCB );
0009f2  4cbe              LDR      r4,|L1.3308|
0009f4  6ae8              LDR      r0,[r5,#0x2c]
0009f6  2601              MOVS     r6,#1
0009f8  6922              LDR      r2,[r4,#0x10]  ; uxTopReadyPriority
0009fa  fa06f100          LSL      r1,r6,r0
0009fe  4311              ORRS     r1,r1,r2
000a00  6121              STR      r1,[r4,#0x10]  ; uxTopReadyPriority
000a02  49bc              LDR      r1,|L1.3316|
000a04  eb000080          ADD      r0,r0,r0,LSL #2
000a08  eb010080          ADD      r0,r1,r0,LSL #2
000a0c  1d29              ADDS     r1,r5,#4
000a0e  f7fffffe          BL       vListInsertEnd
;;;2524   
;;;2525   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000a12  6ae8              LDR      r0,[r5,#0x2c]
000a14  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000a16  6ac9              LDR      r1,[r1,#0x2c]
000a18  4288              CMP      r0,r1
;;;2526   	{
;;;2527   		/* Return true if the task removed from the event list has
;;;2528   		a higher priority than the calling task.  This allows
;;;2529   		the calling task to know if it should force a context
;;;2530   		switch now. */
;;;2531   		xReturn = pdTRUE;
000a1a  bf86              ITTE     HI
000a1c  2001              MOVHI    r0,#1
;;;2532   
;;;2533   		/* Mark that a yield is pending in case the user is not using the
;;;2534   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2535   		xYieldPending = pdTRUE;
000a1e  61e6              STRHI    r6,[r4,#0x1c]  ; xYieldPending
;;;2536   	}
;;;2537   	else
;;;2538   	{
;;;2539   		xReturn = pdFALSE;
000a20  2000              MOVLS    r0,#0
;;;2540   	}
;;;2541   
;;;2542   	return xReturn;
;;;2543   }
000a22  bd70              POP      {r4-r6,pc}
;;;2544   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSetTimeOutState PROC
;;;2545   
;;;2546   void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
000a24  49b1              LDR      r1,|L1.3308|
;;;2547   {
;;;2548   	configASSERT( pxTimeOut );
;;;2549   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000a26  6a0a              LDR      r2,[r1,#0x20]  ; xNumOfOverflows
;;;2550   	pxTimeOut->xTimeOnEntering = xTickCount;
000a28  6002              STR      r2,[r0,#0]
000a2a  68c9              LDR      r1,[r1,#0xc]  ; xTickCount
000a2c  6041              STR      r1,[r0,#4]
;;;2551   }
000a2e  4770              BX       lr
;;;2552   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskCheckForTimeOut PROC
;;;2553   
;;;2554   BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
000a30  b570              PUSH     {r4-r6,lr}
;;;2555   {
000a32  460d              MOV      r5,r1
000a34  4604              MOV      r4,r0
;;;2556   BaseType_t xReturn;
;;;2557   
;;;2558   	configASSERT( pxTimeOut );
;;;2559   	configASSERT( pxTicksToWait );
;;;2560   
;;;2561   	taskENTER_CRITICAL();
000a36  f7fffffe          BL       vPortEnterCritical
;;;2562   	{
;;;2563   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;2564   		const TickType_t xConstTickCount = xTickCount;
000a3a  48ac              LDR      r0,|L1.3308|
000a3c  68c1              LDR      r1,[r0,#0xc]  ; xTickCount
;;;2565   
;;;2566   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;2567   			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
;;;2568   			the maximum block time then the task should block indefinitely, and
;;;2569   			therefore never time out. */
;;;2570   			if( *pxTicksToWait == portMAX_DELAY )
000a3e  682a              LDR      r2,[r5,#0]
000a40  f1b23fff          CMP      r2,#0xffffffff
;;;2571   			{
;;;2572   				xReturn = pdFALSE;
000a44  bf08              IT       EQ
000a46  2400              MOVEQ    r4,#0
000a48  d014              BEQ      |L1.2676|
;;;2573   			}
;;;2574   			else /* We are not blocking indefinitely, perform the checks below. */
;;;2575   		#endif
;;;2576   
;;;2577   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
000a4a  6823              LDR      r3,[r4,#0]
000a4c  f8d0c020          LDR      r12,[r0,#0x20]  ; xNumOfOverflows
000a50  4563              CMP      r3,r12
000a52  d002              BEQ      |L1.2650|
000a54  6863              LDR      r3,[r4,#4]
000a56  428b              CMP      r3,r1
000a58  d90b              BLS      |L1.2674|
                  |L1.2650|
;;;2578   		{
;;;2579   			/* The tick count is greater than the time at which vTaskSetTimeout()
;;;2580   			was called, but has also overflowed since vTaskSetTimeOut() was called.
;;;2581   			It must have wrapped all the way around and gone past us again. This
;;;2582   			passed since vTaskSetTimeout() was called. */
;;;2583   			xReturn = pdTRUE;
;;;2584   		}
;;;2585   		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
000a5a  6863              LDR      r3,[r4,#4]
000a5c  1ac9              SUBS     r1,r1,r3
000a5e  428a              CMP      r2,r1
000a60  d907              BLS      |L1.2674|
;;;2586   		{
;;;2587   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;2588   			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
000a62  1a51              SUBS     r1,r2,r1
000a64  6029              STR      r1,[r5,#0]
000a66  6a01              LDR      r1,[r0,#0x20]  ; xNumOfOverflows
000a68  6021              STR      r1,[r4,#0]
000a6a  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
;;;2589   			vTaskSetTimeOutState( pxTimeOut );
;;;2590   			xReturn = pdFALSE;
000a6c  6060              STR      r0,[r4,#4]
000a6e  2400              MOVS     r4,#0
000a70  e000              B        |L1.2676|
                  |L1.2674|
;;;2591   		}
;;;2592   		else
;;;2593   		{
;;;2594   			xReturn = pdTRUE;
000a72  2401              MOVS     r4,#1
                  |L1.2676|
;;;2595   		}
;;;2596   	}
;;;2597   	taskEXIT_CRITICAL();
000a74  f7fffffe          BL       vPortExitCritical
;;;2598   
;;;2599   	return xReturn;
000a78  4620              MOV      r0,r4
;;;2600   }
000a7a  bd70              POP      {r4-r6,pc}
;;;2601   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskMissedYield PROC
;;;2602   
;;;2603   void vTaskMissedYield( void )
000a7c  499b              LDR      r1,|L1.3308|
;;;2604   {
;;;2605   	xYieldPending = pdTRUE;
000a7e  2001              MOVS     r0,#1
000a80  61c8              STR      r0,[r1,#0x1c]  ; xYieldPending
;;;2606   }
000a82  4770              BX       lr
;;;2607   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskGetCurrentTaskHandle PROC
;;;3343   
;;;3344   	TaskHandle_t xTaskGetCurrentTaskHandle( void )
000a84  4899              LDR      r0,|L1.3308|
;;;3345   	{
;;;3346   	TaskHandle_t xReturn;
;;;3347   
;;;3348   		/* A critical section is not required as this is not called from
;;;3349   		an interrupt and the current TCB will always be the same for any
;;;3350   		individual execution thread. */
;;;3351   		xReturn = pxCurrentTCB;
000a86  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
;;;3352   
;;;3353   		return xReturn;
;;;3354   	}
000a88  4770              BX       lr
;;;3355   
                          ENDP

                  xTaskGetSchedulerState PROC
;;;3360   
;;;3361   	BaseType_t xTaskGetSchedulerState( void )
000a8a  4898              LDR      r0,|L1.3308|
;;;3362   	{
;;;3363   	BaseType_t xReturn;
;;;3364   
;;;3365   		if( xSchedulerRunning == pdFALSE )
000a8c  6941              LDR      r1,[r0,#0x14]  ; xSchedulerRunning
000a8e  2900              CMP      r1,#0
;;;3366   		{
;;;3367   			xReturn = taskSCHEDULER_NOT_STARTED;
000a90  bf04              ITT      EQ
000a92  2001              MOVEQ    r0,#1
;;;3368   		}
;;;3369   		else
;;;3370   		{
;;;3371   			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
;;;3372   			{
;;;3373   				xReturn = taskSCHEDULER_RUNNING;
;;;3374   			}
;;;3375   			else
;;;3376   			{
;;;3377   				xReturn = taskSCHEDULER_SUSPENDED;
;;;3378   			}
;;;3379   		}
;;;3380   
;;;3381   		return xReturn;
;;;3382   	}
000a94  4770              BXEQ     lr
000a96  6ac0              LDR      r0,[r0,#0x2c]         ;3371  ; uxSchedulerSuspended
000a98  2800              CMP      r0,#0                 ;3371
000a9a  bf0c              ITE      EQ                    ;3373
000a9c  2002              MOVEQ    r0,#2                 ;3373
000a9e  2000              MOVNE    r0,#0                 ;3377
000aa0  4770              BX       lr
;;;3383   
                          ENDP

                  vTaskPriorityInherit PROC
;;;3388   
;;;3389   	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
000aa2  b570              PUSH     {r4-r6,lr}
;;;3390   	{
;;;3391   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
000aa4  0004              MOVS     r4,r0
;;;3392   
;;;3393   		/* If the mutex was given back by an interrupt while the queue was
;;;3394   		locked then the mutex holder might now be NULL. */
;;;3395   		if( pxMutexHolder != NULL )
;;;3396   		{
;;;3397   			/* If the holder of the mutex has a priority below the priority of
;;;3398   			the task attempting to obtain the mutex then it will temporarily
;;;3399   			inherit the priority of the task attempting to obtain the mutex. */
;;;3400   			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
;;;3401   			{
;;;3402   				/* Adjust the mutex holder state to account for its new
;;;3403   				priority.  Only reset the event list item value if the value is
;;;3404   				not	being used for anything else. */
;;;3405   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
;;;3406   				{
;;;3407   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;3408   				}
;;;3409   				else
;;;3410   				{
;;;3411   					mtCOVERAGE_TEST_MARKER();
;;;3412   				}
;;;3413   
;;;3414   				/* If the task being modified is in the ready state it will need
;;;3415   				to be moved into a new list. */
;;;3416   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
;;;3417   				{
;;;3418   					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
;;;3419   					{
;;;3420   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;3421   					}
;;;3422   					else
;;;3423   					{
;;;3424   						mtCOVERAGE_TEST_MARKER();
;;;3425   					}
;;;3426   
;;;3427   					/* Inherit the priority before being moved into the new list. */
;;;3428   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
;;;3429   					prvAddTaskToReadyList( pxTCB );
;;;3430   				}
;;;3431   				else
;;;3432   				{
;;;3433   					/* Just inherit the priority. */
;;;3434   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
;;;3435   				}
;;;3436   
;;;3437   				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
;;;3438   			}
;;;3439   			else
;;;3440   			{
;;;3441   				mtCOVERAGE_TEST_MARKER();
;;;3442   			}
;;;3443   		}
;;;3444   		else
;;;3445   		{
;;;3446   			mtCOVERAGE_TEST_MARKER();
;;;3447   		}
;;;3448   	}
000aa6  bf08              IT       EQ
000aa8  bd70              POPEQ    {r4-r6,pc}
000aaa  4d90              LDR      r5,|L1.3308|
000aac  6ae0              LDR      r0,[r4,#0x2c]         ;3400
000aae  6829              LDR      r1,[r5,#0]            ;3400  ; pxCurrentTCB
000ab0  6ac9              LDR      r1,[r1,#0x2c]         ;3400
000ab2  4281              CMP      r1,r0                 ;3400
000ab4  bf98              IT       LS
000ab6  bd70              POPLS    {r4-r6,pc}
000ab8  69a0              LDR      r0,[r4,#0x18]         ;3405
000aba  f0104f00          TST      r0,#0x80000000        ;3405
000abe  d104              BNE      |L1.2762|
000ac0  6828              LDR      r0,[r5,#0]            ;3407  ; pxCurrentTCB
000ac2  6ac0              LDR      r0,[r0,#0x2c]         ;3407
000ac4  f1c00005          RSB      r0,r0,#5              ;3407
000ac8  61a0              STR      r0,[r4,#0x18]         ;3407
                  |L1.2762|
000aca  6ae1              LDR      r1,[r4,#0x2c]         ;3416
000acc  4e89              LDR      r6,|L1.3316|
000ace  eb010181          ADD      r1,r1,r1,LSL #2       ;3416
000ad2  6960              LDR      r0,[r4,#0x14]         ;3416
000ad4  eb060181          ADD      r1,r6,r1,LSL #2       ;3416
000ad8  4288              CMP      r0,r1                 ;3416
000ada  d120              BNE      |L1.2846|
000adc  1d20              ADDS     r0,r4,#4              ;3418
000ade  f7fffffe          BL       uxListRemove
000ae2  2101              MOVS     r1,#1                 ;3420
000ae4  b958              CBNZ     r0,|L1.2814|
000ae6  6ae0              LDR      r0,[r4,#0x2c]         ;3420
000ae8  eb000280          ADD      r2,r0,r0,LSL #2       ;3420
000aec  f8562022          LDR      r2,[r6,r2,LSL #2]     ;3420
000af0  b92a              CBNZ     r2,|L1.2814|
000af2  692a              LDR      r2,[r5,#0x10]         ;3420  ; uxTopReadyPriority
000af4  fa01f000          LSL      r0,r1,r0              ;3420
000af8  ea220000          BIC      r0,r2,r0              ;3420
000afc  6128              STR      r0,[r5,#0x10]         ;3420  ; uxTopReadyPriority
                  |L1.2814|
000afe  6828              LDR      r0,[r5,#0]            ;3428  ; pxCurrentTCB
000b00  6ac0              LDR      r0,[r0,#0x2c]         ;3428
000b02  62e0              STR      r0,[r4,#0x2c]         ;3429
000b04  692a              LDR      r2,[r5,#0x10]         ;3429  ; uxTopReadyPriority
000b06  4081              LSLS     r1,r1,r0              ;3429
000b08  4311              ORRS     r1,r1,r2              ;3429
000b0a  6129              STR      r1,[r5,#0x10]         ;3429  ; uxTopReadyPriority
000b0c  eb000080          ADD      r0,r0,r0,LSL #2       ;3429
000b10  eb060080          ADD      r0,r6,r0,LSL #2       ;3429
000b14  1d21              ADDS     r1,r4,#4              ;3429
000b16  e8bd4070          POP      {r4-r6,lr}            ;3429
000b1a  f7ffbffe          B.W      vListInsertEnd
                  |L1.2846|
000b1e  6828              LDR      r0,[r5,#0]            ;3434  ; pxCurrentTCB
000b20  6ac0              LDR      r0,[r0,#0x2c]         ;3434
000b22  62e0              STR      r0,[r4,#0x2c]         ;3434
000b24  bd70              POP      {r4-r6,pc}
;;;3449   
                          ENDP

                  xTaskPriorityDisinherit PROC
;;;3454   
;;;3455   	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
000b26  b510              PUSH     {r4,lr}
;;;3456   	{
;;;3457   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
000b28  0004              MOVS     r4,r0
;;;3458   	BaseType_t xReturn = pdFALSE;
000b2a  f04f0100          MOV      r1,#0
000b2e  d031              BEQ      |L1.2964|
;;;3459   
;;;3460   		if( pxMutexHolder != NULL )
;;;3461   		{
;;;3462   			/* A task can only have an inherited priority if it holds the mutex.
;;;3463   			If the mutex is held by a task then it cannot be given from an
;;;3464   			interrupt, and if a mutex is given by the holding task then it must
;;;3465   			be the running state task. */
;;;3466   			configASSERT( pxTCB == pxCurrentTCB );
;;;3467   
;;;3468   			configASSERT( pxTCB->uxMutexesHeld );
;;;3469   			( pxTCB->uxMutexesHeld )--;
000b30  6ca0              LDR      r0,[r4,#0x48]
000b32  1e40              SUBS     r0,r0,#1
;;;3470   
;;;3471   			/* Has the holder of the mutex inherited the priority of another
;;;3472   			task? */
;;;3473   			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
000b34  64a0              STR      r0,[r4,#0x48]
000b36  6c63              LDR      r3,[r4,#0x44]
000b38  6ae2              LDR      r2,[r4,#0x2c]
000b3a  429a              CMP      r2,r3
000b3c  d02a              BEQ      |L1.2964|
;;;3474   			{
;;;3475   				/* Only disinherit if no other mutexes are held. */
;;;3476   				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
000b3e  bb48              CBNZ     r0,|L1.2964|
;;;3477   				{
;;;3478   					/* A task can only have an inherited priority if it holds
;;;3479   					the mutex.  If the mutex is held by a task then it cannot be
;;;3480   					given from an interrupt, and if a mutex is given by the
;;;3481   					holding	task then it must be the running state task.  Remove
;;;3482   					the	holding task from the ready	list. */
;;;3483   					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000b40  1d20              ADDS     r0,r4,#4
000b42  f7fffffe          BL       uxListRemove
;;;3484   					{
;;;3485   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000b46  4a6b              LDR      r2,|L1.3316|
000b48  4968              LDR      r1,|L1.3308|
000b4a  2301              MOVS     r3,#1
000b4c  b970              CBNZ     r0,|L1.2924|
000b4e  6ae0              LDR      r0,[r4,#0x2c]
000b50  eb000c80          ADD      r12,r0,r0,LSL #2
000b54  f852c02c          LDR      r12,[r2,r12,LSL #2]
000b58  f1bc0f00          CMP      r12,#0
000b5c  d106              BNE      |L1.2924|
000b5e  f8d1c010          LDR      r12,[r1,#0x10]  ; uxTopReadyPriority
000b62  fa03f000          LSL      r0,r3,r0
000b66  ea2c0000          BIC      r0,r12,r0
000b6a  6108              STR      r0,[r1,#0x10]  ; uxTopReadyPriority
                  |L1.2924|
;;;3486   					}
;;;3487   					else
;;;3488   					{
;;;3489   						mtCOVERAGE_TEST_MARKER();
;;;3490   					}
;;;3491   
;;;3492   					/* Disinherit the priority before adding the task into the
;;;3493   					new	ready list. */
;;;3494   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;3495   					pxTCB->uxPriority = pxTCB->uxBasePriority;
000b6c  6c60              LDR      r0,[r4,#0x44]
;;;3496   
;;;3497   					/* Reset the event list item value.  It cannot be in use for
;;;3498   					any other purpose if this task is running, and it must be
;;;3499   					running to give back the mutex. */
;;;3500   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000b6e  62e0              STR      r0,[r4,#0x2c]
000b70  f1c00005          RSB      r0,r0,#5
;;;3501   					prvAddTaskToReadyList( pxTCB );
000b74  61a0              STR      r0,[r4,#0x18]
000b76  6ae0              LDR      r0,[r4,#0x2c]
000b78  f8d1c010          LDR      r12,[r1,#0x10]  ; uxTopReadyPriority
000b7c  4083              LSLS     r3,r3,r0
000b7e  ea43030c          ORR      r3,r3,r12
000b82  610b              STR      r3,[r1,#0x10]  ; uxTopReadyPriority
000b84  eb000080          ADD      r0,r0,r0,LSL #2
000b88  eb020080          ADD      r0,r2,r0,LSL #2
000b8c  1d21              ADDS     r1,r4,#4
000b8e  f7fffffe          BL       vListInsertEnd
;;;3502   
;;;3503   					/* Return true to indicate that a context switch is required.
;;;3504   					This is only actually required in the corner case whereby
;;;3505   					multiple mutexes were held and the mutexes were given back
;;;3506   					in an order different to that in which they were taken.
;;;3507   					If a context switch did not occur when the first mutex was
;;;3508   					returned, even if a task was waiting on it, then a context
;;;3509   					switch should occur when the last mutex is returned whether
;;;3510   					a task is waiting on it or not. */
;;;3511   					xReturn = pdTRUE;
000b92  2101              MOVS     r1,#1
                  |L1.2964|
;;;3512   				}
;;;3513   				else
;;;3514   				{
;;;3515   					mtCOVERAGE_TEST_MARKER();
;;;3516   				}
;;;3517   			}
;;;3518   			else
;;;3519   			{
;;;3520   				mtCOVERAGE_TEST_MARKER();
;;;3521   			}
;;;3522   		}
;;;3523   		else
;;;3524   		{
;;;3525   			mtCOVERAGE_TEST_MARKER();
;;;3526   		}
;;;3527   
;;;3528   		return xReturn;
000b94  4608              MOV      r0,r1
;;;3529   	}
000b96  bd10              POP      {r4,pc}
;;;3530   
                          ENDP

                  uxTaskResetEventItemValue PROC
;;;3839   
;;;3840   TickType_t uxTaskResetEventItemValue( void )
000b98  4954              LDR      r1,|L1.3308|
;;;3841   {
;;;3842   TickType_t uxReturn;
;;;3843   
;;;3844   	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000b9a  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;3845   
;;;3846   	/* Reset the event list item to its normal value - so it can be used with
;;;3847   	queues and semaphores. */
;;;3848   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000b9c  680a              LDR      r2,[r1,#0]  ; pxCurrentTCB
000b9e  6980              LDR      r0,[r0,#0x18]         ;3844
000ba0  6ad2              LDR      r2,[r2,#0x2c]
000ba2  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000ba4  f1c20205          RSB      r2,r2,#5
000ba8  618a              STR      r2,[r1,#0x18]
;;;3849   
;;;3850   	return uxReturn;
;;;3851   }
000baa  4770              BX       lr
;;;3852   /*-----------------------------------------------------------*/
                          ENDP

                  pvTaskIncrementMutexHeldCount PROC
;;;3855   
;;;3856   	void *pvTaskIncrementMutexHeldCount( void )
000bac  494f              LDR      r1,|L1.3308|
;;;3857   	{
;;;3858   		/* If xSemaphoreCreateMutex() is called before any tasks have been created
;;;3859   		then pxCurrentTCB will be NULL. */
;;;3860   		if( pxCurrentTCB != NULL )
000bae  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
000bb0  b118              CBZ      r0,|L1.3002|
;;;3861   		{
;;;3862   			( pxCurrentTCB->uxMutexesHeld )++;
000bb2  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
000bb4  6c82              LDR      r2,[r0,#0x48]
000bb6  1c52              ADDS     r2,r2,#1
000bb8  6482              STR      r2,[r0,#0x48]
                  |L1.3002|
;;;3863   		}
;;;3864   
;;;3865   		return pxCurrentTCB;
000bba  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;3866   	}
000bbc  4770              BX       lr
;;;3867   
                          ENDP

                  ulTaskNotifyTake PROC
;;;3872   
;;;3873   	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
000bbe  e92d41f0          PUSH     {r4-r8,lr}
;;;3874   	{
000bc2  460d              MOV      r5,r1
000bc4  4606              MOV      r6,r0
;;;3875   	TickType_t xTimeToWake;
;;;3876   	uint32_t ulReturn;
;;;3877   
;;;3878   		taskENTER_CRITICAL();
000bc6  f7fffffe          BL       vPortEnterCritical
;;;3879   		{
;;;3880   			/* Only block if the notification count is not already non-zero. */
;;;3881   			if( pxCurrentTCB->ulNotifiedValue == 0UL )
000bca  4c48              LDR      r4,|L1.3308|
000bcc  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000bce  6cc0              LDR      r0,[r0,#0x4c]
000bd0  b9e0              CBNZ     r0,|L1.3084|
;;;3882   			{
;;;3883   				/* Mark this task as waiting for a notification. */
;;;3884   				pxCurrentTCB->eNotifyState = eWaitingNotification;
000bd2  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000bd4  2701              MOVS     r7,#1
000bd6  f8807050          STRB     r7,[r0,#0x50]
;;;3885   
;;;3886   				if( xTicksToWait > ( TickType_t ) 0 )
000bda  b1bd              CBZ      r5,|L1.3084|
;;;3887   				{
;;;3888   					/* The task is going to block.  First it must be removed
;;;3889   					from the ready list. */
;;;3890   					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000bdc  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000bde  1d00              ADDS     r0,r0,#4
000be0  f7fffffe          BL       uxListRemove
000be4  b940              CBNZ     r0,|L1.3064|
;;;3891   					{
;;;3892   						/* The current task must be in a ready list, so there is
;;;3893   						no need to check, and the port reset macro can be called
;;;3894   						directly. */
;;;3895   						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000be6  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000be8  6921              LDR      r1,[r4,#0x10]  ; uxTopReadyPriority
000bea  f890002c          LDRB     r0,[r0,#0x2c]
000bee  fa07f000          LSL      r0,r7,r0
000bf2  ea210000          BIC      r0,r1,r0
000bf6  6120              STR      r0,[r4,#0x10]  ; uxTopReadyPriority
                  |L1.3064|
;;;3896   					}
;;;3897   					else
;;;3898   					{
;;;3899   						mtCOVERAGE_TEST_MARKER();
;;;3900   					}
;;;3901   
;;;3902   					#if ( INCLUDE_vTaskSuspend == 1 )
;;;3903   					{
;;;3904   						if( xTicksToWait == portMAX_DELAY )
000bf8  f1b53fff          CMP      r5,#0xffffffff
000bfc  d014              BEQ      |L1.3112|
;;;3905   						{
;;;3906   							/* Add the task to the suspended task list instead
;;;3907   							of a delayed task list to ensure the task is not
;;;3908   							woken by a timing event.  It will block
;;;3909   							indefinitely. */
;;;3910   							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
;;;3911   						}
;;;3912   						else
;;;3913   						{
;;;3914   							/* Calculate the time at which the task should be
;;;3915   							woken if no notification events occur.  This may
;;;3916   							overflow but this doesn't matter, the scheduler will
;;;3917   							handle it. */
;;;3918   							xTimeToWake = xTickCount + xTicksToWait;
000bfe  68e0              LDR      r0,[r4,#0xc]  ; xTickCount
000c00  4428              ADD      r0,r0,r5
;;;3919   							prvAddCurrentTaskToDelayedList( xTimeToWake );
000c02  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;3920   						}
;;;3921   					}
;;;3922   					#else /* INCLUDE_vTaskSuspend */
;;;3923   					{
;;;3924   							/* Calculate the time at which the task should be
;;;3925   							woken if the event does not occur.  This may
;;;3926   							overflow but this doesn't matter, the scheduler will
;;;3927   							handle it. */
;;;3928   							xTimeToWake = xTickCount + xTicksToWait;
;;;3929   							prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;3930   					}
;;;3931   					#endif /* INCLUDE_vTaskSuspend */
;;;3932   
;;;3933   					/* All ports are written to allow a yield in a critical
;;;3934   					section (some will yield immediately, others wait until the
;;;3935   					critical section exits) - but it is not something that
;;;3936   					application code should ever do. */
;;;3937   					portYIELD_WITHIN_API();
000c06  bf00              NOP      
                  |L1.3080|
000c08  f7fffffe          BL       vPortYield
                  |L1.3084|
;;;3938   				}
;;;3939   				else
;;;3940   				{
;;;3941   					mtCOVERAGE_TEST_MARKER();
;;;3942   				}
;;;3943   			}
;;;3944   			else
;;;3945   			{
;;;3946   				mtCOVERAGE_TEST_MARKER();
;;;3947   			}
;;;3948   		}
;;;3949   		taskEXIT_CRITICAL();
000c0c  f7fffffe          BL       vPortExitCritical
;;;3950   
;;;3951   		taskENTER_CRITICAL();
000c10  f7fffffe          BL       vPortEnterCritical
;;;3952   		{
;;;3953   			ulReturn = pxCurrentTCB->ulNotifiedValue;
000c14  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000c16  6cc5              LDR      r5,[r0,#0x4c]
000c18  2000              MOVS     r0,#0
;;;3954   
;;;3955   			if( ulReturn != 0UL )
000c1a  b175              CBZ      r5,|L1.3130|
;;;3956   			{
;;;3957   				if( xClearCountOnExit != pdFALSE )
;;;3958   				{
;;;3959   					pxCurrentTCB->ulNotifiedValue = 0UL;
;;;3960   				}
;;;3961   				else
;;;3962   				{
;;;3963   					( pxCurrentTCB->ulNotifiedValue )--;
000c1c  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000c1e  2e00              CMP      r6,#0                 ;3957
000c20  bf18              IT       NE                    ;3959
000c22  64c8              STRNE    r0,[r1,#0x4c]         ;3959
000c24  d006              BEQ      |L1.3124|
000c26  e008              B        |L1.3130|
                  |L1.3112|
000c28  6820              LDR      r0,[r4,#0]            ;3910  ; pxCurrentTCB
000c2a  1d01              ADDS     r1,r0,#4              ;3910
000c2c  482e              LDR      r0,|L1.3304|
000c2e  f7fffffe          BL       vListInsertEnd
000c32  e7e9              B        |L1.3080|
                  |L1.3124|
000c34  6cca              LDR      r2,[r1,#0x4c]
000c36  1e52              SUBS     r2,r2,#1
000c38  64ca              STR      r2,[r1,#0x4c]
                  |L1.3130|
;;;3964   				}
;;;3965   			}
;;;3966   			else
;;;3967   			{
;;;3968   				mtCOVERAGE_TEST_MARKER();
;;;3969   			}
;;;3970   
;;;3971   			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
000c3a  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000c3c  f8810050          STRB     r0,[r1,#0x50]
;;;3972   		}
;;;3973   		taskEXIT_CRITICAL();
000c40  f7fffffe          BL       vPortExitCritical
;;;3974   
;;;3975   		return ulReturn;
000c44  4628              MOV      r0,r5
;;;3976   	}
000c46  e8bd81f0          POP      {r4-r8,pc}
;;;3977   
                          ENDP

                  xTaskNotifyWait PROC
;;;3982   
;;;3983   	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
000c4a  e92d41f0          PUSH     {r4-r8,lr}
;;;3984   	{
000c4e  461d              MOV      r5,r3
000c50  4617              MOV      r7,r2
000c52  460e              MOV      r6,r1
000c54  4680              MOV      r8,r0
;;;3985   	TickType_t xTimeToWake;
;;;3986   	BaseType_t xReturn;
;;;3987   
;;;3988   		taskENTER_CRITICAL();
000c56  f7fffffe          BL       vPortEnterCritical
;;;3989   		{
;;;3990   			/* Only block if a notification is not already pending. */
;;;3991   			if( pxCurrentTCB->eNotifyState != eNotified )
000c5a  4c24              LDR      r4,|L1.3308|
000c5c  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000c5e  f8900050          LDRB     r0,[r0,#0x50]
000c62  2802              CMP      r0,#2
000c64  d022              BEQ      |L1.3244|
;;;3992   			{
;;;3993   				/* Clear bits in the task's notification value as bits may get
;;;3994   				set	by the notifying task or interrupt.  This can be used to
;;;3995   				clear the value to zero. */
;;;3996   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
000c66  6823              LDR      r3,[r4,#0]  ; pxCurrentTCB
000c68  6cd8              LDR      r0,[r3,#0x4c]
000c6a  ea200008          BIC      r0,r0,r8
000c6e  64d8              STR      r0,[r3,#0x4c]
;;;3997   
;;;3998   				/* Mark this task as waiting for a notification. */
;;;3999   				pxCurrentTCB->eNotifyState = eWaitingNotification;
000c70  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000c72  f04f0801          MOV      r8,#1
000c76  f8808050          STRB     r8,[r0,#0x50]
;;;4000   
;;;4001   				if( xTicksToWait > ( TickType_t ) 0 )
000c7a  b1bd              CBZ      r5,|L1.3244|
;;;4002   				{
;;;4003   					/* The task is going to block.  First it must be removed
;;;4004   					from the	ready list. */
;;;4005   					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000c7c  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000c7e  1d00              ADDS     r0,r0,#4
000c80  f7fffffe          BL       uxListRemove
000c84  b940              CBNZ     r0,|L1.3224|
;;;4006   					{
;;;4007   						/* The current task must be in a ready list, so there is
;;;4008   						no need to check, and the port reset macro can be called
;;;4009   						directly. */
;;;4010   						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000c86  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000c88  6921              LDR      r1,[r4,#0x10]  ; uxTopReadyPriority
000c8a  f890002c          LDRB     r0,[r0,#0x2c]
000c8e  fa08f000          LSL      r0,r8,r0
000c92  ea210000          BIC      r0,r1,r0
000c96  6120              STR      r0,[r4,#0x10]  ; uxTopReadyPriority
                  |L1.3224|
;;;4011   					}
;;;4012   					else
;;;4013   					{
;;;4014   						mtCOVERAGE_TEST_MARKER();
;;;4015   					}
;;;4016   
;;;4017   					#if ( INCLUDE_vTaskSuspend == 1 )
;;;4018   					{
;;;4019   						if( xTicksToWait == portMAX_DELAY )
000c98  f1b53fff          CMP      r5,#0xffffffff
000c9c  d02c              BEQ      |L1.3320|
;;;4020   						{
;;;4021   							/* Add the task to the suspended task list instead
;;;4022   							of a delayed task list to ensure the task is not
;;;4023   							woken by a timing event.  It will block
;;;4024   							indefinitely. */
;;;4025   							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
;;;4026   						}
;;;4027   						else
;;;4028   						{
;;;4029   							/* Calculate the time at which the task should be
;;;4030   							woken if no notification events occur.  This may
;;;4031   							overflow but this doesn't matter, the scheduler will
;;;4032   							handle it. */
;;;4033   							xTimeToWake = xTickCount + xTicksToWait;
000c9e  68e0              LDR      r0,[r4,#0xc]  ; xTickCount
000ca0  4428              ADD      r0,r0,r5
;;;4034   							prvAddCurrentTaskToDelayedList( xTimeToWake );
000ca2  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4035   						}
;;;4036   					}
;;;4037   					#else /* INCLUDE_vTaskSuspend */
;;;4038   					{
;;;4039   							/* Calculate the time at which the task should be
;;;4040   							woken if the event does not occur.  This may
;;;4041   							overflow but this doesn't matter, the scheduler will
;;;4042   							handle it. */
;;;4043   							xTimeToWake = xTickCount + xTicksToWait;
;;;4044   							prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;4045   					}
;;;4046   					#endif /* INCLUDE_vTaskSuspend */
;;;4047   
;;;4048   					/* All ports are written to allow a yield in a critical
;;;4049   					section (some will yield immediately, others wait until the
;;;4050   					critical section exits) - but it is not something that
;;;4051   					application code should ever do. */
;;;4052   					portYIELD_WITHIN_API();
000ca6  bf00              NOP      
                  |L1.3240|
000ca8  f7fffffe          BL       vPortYield
                  |L1.3244|
;;;4053   				}
;;;4054   				else
;;;4055   				{
;;;4056   					mtCOVERAGE_TEST_MARKER();
;;;4057   				}
;;;4058   			}
;;;4059   			else
;;;4060   			{
;;;4061   				mtCOVERAGE_TEST_MARKER();
;;;4062   			}
;;;4063   		}
;;;4064   		taskEXIT_CRITICAL();
000cac  f7fffffe          BL       vPortExitCritical
;;;4065   
;;;4066   		taskENTER_CRITICAL();
000cb0  f7fffffe          BL       vPortEnterCritical
;;;4067   		{
;;;4068   			if( pulNotificationValue != NULL )
000cb4  b117              CBZ      r7,|L1.3260|
;;;4069   			{
;;;4070   				/* Output the current notification value, which may or may not
;;;4071   				have changed. */
;;;4072   				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
000cb6  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000cb8  6cc0              LDR      r0,[r0,#0x4c]
000cba  6038              STR      r0,[r7,#0]
                  |L1.3260|
;;;4073   			}
;;;4074   
;;;4075   			/* If eNotifyValue is set then either the task never entered the
;;;4076   			blocked state (because a notification was already pending) or the
;;;4077   			task unblocked because of a notification.  Otherwise the task
;;;4078   			unblocked because of a timeout. */
;;;4079   			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
000cbc  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000cbe  f8900050          LDRB     r0,[r0,#0x50]
000cc2  2801              CMP      r0,#1
;;;4080   			{
;;;4081   				/* A notification was not received. */
;;;4082   				xReturn = pdFALSE;
000cc4  bf08              IT       EQ
000cc6  2500              MOVEQ    r5,#0
000cc8  d004              BEQ      |L1.3284|
;;;4083   			}
;;;4084   			else
;;;4085   			{
;;;4086   				/* A notification was already pending or a notification was
;;;4087   				received while the task was waiting. */
;;;4088   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
000cca  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000ccc  6cc1              LDR      r1,[r0,#0x4c]
000cce  43b1              BICS     r1,r1,r6
000cd0  64c1              STR      r1,[r0,#0x4c]
;;;4089   				xReturn = pdTRUE;
000cd2  2501              MOVS     r5,#1
                  |L1.3284|
;;;4090   			}
;;;4091   
;;;4092   			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
000cd4  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000cd6  2000              MOVS     r0,#0
000cd8  f8810050          STRB     r0,[r1,#0x50]
;;;4093   		}
;;;4094   		taskEXIT_CRITICAL();
000cdc  f7fffffe          BL       vPortExitCritical
;;;4095   
;;;4096   		return xReturn;
000ce0  4628              MOV      r0,r5
;;;4097   	}
000ce2  e8bd81f0          POP      {r4-r8,pc}
000ce6  0000              DCW      0x0000
                  |L1.3304|
                          DCD      ||.bss||+0xb4
                  |L1.3308|
                          DCD      ||.data||
                  |L1.3312|
                          DCD      ||.bss||+0x8c
                  |L1.3316|
                          DCD      ||.bss||
                  |L1.3320|
000cf8  6820              LDR      r0,[r4,#0]            ;4025  ; pxCurrentTCB
000cfa  1d01              ADDS     r1,r0,#4              ;4025
000cfc  4875              LDR      r0,|L1.3796|
000cfe  f7fffffe          BL       vListInsertEnd
000d02  e7d1              B        |L1.3240|
;;;4098   
                          ENDP

                  xTaskGenericNotify PROC
;;;4103   
;;;4104   	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
000d04  e92d41f0          PUSH     {r4-r8,lr}
;;;4105   	{
000d08  461e              MOV      r6,r3
000d0a  4690              MOV      r8,r2
000d0c  460d              MOV      r5,r1
;;;4106   	TCB_t * pxTCB;
;;;4107   	eNotifyValue eOriginalNotifyState;
;;;4108   	BaseType_t xReturn = pdPASS;
000d0e  2701              MOVS     r7,#1
;;;4109   
;;;4110   		configASSERT( xTaskToNotify );
;;;4111   		pxTCB = ( TCB_t * ) xTaskToNotify;
000d10  4604              MOV      r4,r0
;;;4112   
;;;4113   		taskENTER_CRITICAL();
000d12  f7fffffe          BL       vPortEnterCritical
;;;4114   		{
;;;4115   			if( pulPreviousNotificationValue != NULL )
000d16  2e00              CMP      r6,#0
;;;4116   			{
;;;4117   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000d18  bf1c              ITT      NE
000d1a  6ce0              LDRNE    r0,[r4,#0x4c]
000d1c  6030              STRNE    r0,[r6,#0]
;;;4118   			}
;;;4119   
;;;4120   			eOriginalNotifyState = pxTCB->eNotifyState;
000d1e  f8940050          LDRB     r0,[r4,#0x50]
;;;4121   
;;;4122   			pxTCB->eNotifyState = eNotified;
000d22  2102              MOVS     r1,#2
000d24  f8841050          STRB     r1,[r4,#0x50]
;;;4123   
;;;4124   			switch( eAction )
000d28  f1b80f05          CMP      r8,#5
000d2c  d210              BCS      |L1.3408|
000d2e  e8dff008          TBB      [pc,r8]
000d32  0f03              DCB      0x0f,0x03
000d34  060e0a00          DCB      0x06,0x0e,0x0a,0x00
;;;4125   			{
;;;4126   				case eSetBits	:
;;;4127   					pxTCB->ulNotifiedValue |= ulValue;
000d38  6ce1              LDR      r1,[r4,#0x4c]
000d3a  4329              ORRS     r1,r1,r5
;;;4128   					break;
000d3c  e001              B        |L1.3394|
;;;4129   
;;;4130   				case eIncrement	:
;;;4131   					( pxTCB->ulNotifiedValue )++;
000d3e  6ce1              LDR      r1,[r4,#0x4c]
000d40  1c49              ADDS     r1,r1,#1
                  |L1.3394|
000d42  64e1              STR      r1,[r4,#0x4c]         ;4127
000d44  e004              B        |L1.3408|
;;;4132   					break;
;;;4133   
;;;4134   				case eSetValueWithOverwrite	:
;;;4135   					pxTCB->ulNotifiedValue = ulValue;
;;;4136   					break;
;;;4137   
;;;4138   				case eSetValueWithoutOverwrite :
;;;4139   					if( eOriginalNotifyState != eNotified )
000d46  2802              CMP      r0,#2
;;;4140   					{
;;;4141   						pxTCB->ulNotifiedValue = ulValue;
;;;4142   					}
;;;4143   					else
;;;4144   					{
;;;4145   						/* The value could not be written to the task. */
;;;4146   						xReturn = pdFAIL;
000d48  bf08              IT       EQ
000d4a  2700              MOVEQ    r7,#0
000d4c  d01b              BEQ      |L1.3462|
000d4e  64e5              STR      r5,[r4,#0x4c]         ;4141
                  |L1.3408|
;;;4147   					}
;;;4148   					break;
;;;4149   
;;;4150   				case eNoAction:
;;;4151   					/* The task is being notified without its notify value being
;;;4152   					updated. */
;;;4153   					break;
;;;4154   			}
;;;4155   
;;;4156   
;;;4157   			/* If the task is in the blocked state specifically to wait for a
;;;4158   			notification then unblock it now. */
;;;4159   			if( eOriginalNotifyState == eWaitingNotification )
000d50  2801              CMP      r0,#1
000d52  d118              BNE      |L1.3462|
;;;4160   			{
;;;4161   				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
000d54  1d20              ADDS     r0,r4,#4
000d56  f7fffffe          BL       uxListRemove
;;;4162   				prvAddTaskToReadyList( pxTCB );
000d5a  4d5f              LDR      r5,|L1.3800|
000d5c  6ae0              LDR      r0,[r4,#0x2c]
000d5e  2101              MOVS     r1,#1
000d60  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000d62  4081              LSLS     r1,r1,r0
000d64  4311              ORRS     r1,r1,r2
000d66  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
000d68  495c              LDR      r1,|L1.3804|
000d6a  eb000080          ADD      r0,r0,r0,LSL #2
000d6e  eb010080          ADD      r0,r1,r0,LSL #2
000d72  1d21              ADDS     r1,r4,#4
000d74  f7fffffe          BL       vListInsertEnd
;;;4163   
;;;4164   				/* The task should not have been on an event list. */
;;;4165   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4166   
;;;4167   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000d78  6ae0              LDR      r0,[r4,#0x2c]
000d7a  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000d7c  6ac9              LDR      r1,[r1,#0x2c]
000d7e  4288              CMP      r0,r1
;;;4168   				{
;;;4169   					/* The notified task has a priority above the currently
;;;4170   					executing task so a yield is required. */
;;;4171   					taskYIELD_IF_USING_PREEMPTION();
000d80  bf88              IT       HI
000d82  f7fffffe          BLHI     vPortYield
                  |L1.3462|
;;;4172   				}
;;;4173   				else
;;;4174   				{
;;;4175   					mtCOVERAGE_TEST_MARKER();
;;;4176   				}
;;;4177   			}
;;;4178   			else
;;;4179   			{
;;;4180   				mtCOVERAGE_TEST_MARKER();
;;;4181   			}
;;;4182   		}
;;;4183   		taskEXIT_CRITICAL();
000d86  f7fffffe          BL       vPortExitCritical
;;;4184   
;;;4185   		return xReturn;
000d8a  4638              MOV      r0,r7
;;;4186   	}
000d8c  e8bd81f0          POP      {r4-r8,pc}
;;;4187   
                          ENDP

                  xTaskNotifyFromISR PROC
;;;4192   
;;;4193   	BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken )
000d90  e92d47f0          PUSH     {r4-r10,lr}
;;;4194   	{
000d94  461e              MOV      r6,r3
000d96  4691              MOV      r9,r2
000d98  460d              MOV      r5,r1
;;;4195   	TCB_t * pxTCB;
;;;4196   	eNotifyValue eOriginalNotifyState;
;;;4197   	BaseType_t xReturn = pdPASS;
000d9a  2701              MOVS     r7,#1
;;;4198   	UBaseType_t uxSavedInterruptStatus;
;;;4199   
;;;4200   		configASSERT( xTaskToNotify );
;;;4201   
;;;4202   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4203   		maximum	system call (or maximum API call) interrupt priority.
;;;4204   		Interrupts that are	above the maximum system call priority are keep
;;;4205   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4206   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4207   		is defined in FreeRTOSConfig.h then
;;;4208   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4209   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4210   		been assigned a priority above the configured maximum system call
;;;4211   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4212   		from interrupts	that have been assigned a priority at or (logically)
;;;4213   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4214   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4215   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4216   		provided on the following link:
;;;4217   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4218   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;4219   
;;;4220   		pxTCB = ( TCB_t * ) xTaskToNotify;
000d9c  4604              MOV      r4,r0
;;;4221   
;;;4222   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000d9e  f7fffffe          BL       ulPortSetInterruptMask
;;;4223   		{
;;;4224   			eOriginalNotifyState = pxTCB->eNotifyState;
000da2  f8941050          LDRB     r1,[r4,#0x50]
000da6  4680              MOV      r8,r0                 ;4222
;;;4225   
;;;4226   			pxTCB->eNotifyState = eNotified;
000da8  2002              MOVS     r0,#2
000daa  f8840050          STRB     r0,[r4,#0x50]
;;;4227   
;;;4228   			switch( eAction )
000dae  f1b90f05          CMP      r9,#5
000db2  d210              BCS      |L1.3542|
000db4  e8dff009          TBB      [pc,r9]
000db8  0f03060e          DCB      0x0f,0x03,0x06,0x0e
000dbc  0a00              DCB      0x0a,0x00
;;;4229   			{
;;;4230   				case eSetBits	:
;;;4231   					pxTCB->ulNotifiedValue |= ulValue;
000dbe  6ce0              LDR      r0,[r4,#0x4c]
000dc0  4328              ORRS     r0,r0,r5
;;;4232   					break;
000dc2  e001              B        |L1.3528|
;;;4233   
;;;4234   				case eIncrement	:
;;;4235   					( pxTCB->ulNotifiedValue )++;
000dc4  6ce0              LDR      r0,[r4,#0x4c]
000dc6  1c40              ADDS     r0,r0,#1
                  |L1.3528|
000dc8  64e0              STR      r0,[r4,#0x4c]         ;4231
000dca  e004              B        |L1.3542|
;;;4236   					break;
;;;4237   
;;;4238   				case eSetValueWithOverwrite	:
;;;4239   					pxTCB->ulNotifiedValue = ulValue;
;;;4240   					break;
;;;4241   
;;;4242   				case eSetValueWithoutOverwrite :
;;;4243   					if( eOriginalNotifyState != eNotified )
000dcc  2902              CMP      r1,#2
;;;4244   					{
;;;4245   						pxTCB->ulNotifiedValue = ulValue;
;;;4246   					}
;;;4247   					else
;;;4248   					{
;;;4249   						/* The value could not be written to the task. */
;;;4250   						xReturn = pdFAIL;
000dce  bf08              IT       EQ
000dd0  2700              MOVEQ    r7,#0
000dd2  d016              BEQ      |L1.3586|
000dd4  64e5              STR      r5,[r4,#0x4c]         ;4245
                  |L1.3542|
;;;4251   					}
;;;4252   					break;
;;;4253   
;;;4254   				case eNoAction :
;;;4255   					/* The task is being notified without its notify value being
;;;4256   					updated. */
;;;4257   					break;
;;;4258   			}
;;;4259   
;;;4260   
;;;4261   			/* If the task is in the blocked state specifically to wait for a
;;;4262   			notification then unblock it now. */
;;;4263   			if( eOriginalNotifyState == eWaitingNotification )
000dd6  2901              CMP      r1,#1
000dd8  d113              BNE      |L1.3586|
;;;4264   			{
;;;4265   				/* The task should not have been on an event list. */
;;;4266   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4267   
;;;4268   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000dda  4d3f              LDR      r5,|L1.3800|
000ddc  6ae8              LDR      r0,[r5,#0x2c]  ; uxSchedulerSuspended
000dde  4689              MOV      r9,r1                 ;4197
000de0  2800              CMP      r0,#0
;;;4269   				{
;;;4270   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
;;;4271   					prvAddTaskToReadyList( pxTCB );
;;;4272   				}
;;;4273   				else
;;;4274   				{
;;;4275   					/* The delayed and ready lists cannot be accessed, so hold
;;;4276   					this task pending until the scheduler is resumed. */
;;;4277   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000de2  bf1c              ITT      NE
000de4  f1040118          ADDNE    r1,r4,#0x18
000de8  483d              LDRNE    r0,|L1.3808|
000dea  d010              BEQ      |L1.3598|
                  |L1.3564|
000dec  f7fffffe          BL       vListInsertEnd
;;;4278   				}
;;;4279   
;;;4280   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000df0  6ae0              LDR      r0,[r4,#0x2c]
000df2  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000df4  6ac9              LDR      r1,[r1,#0x2c]
000df6  4288              CMP      r0,r1
000df8  d903              BLS      |L1.3586|
;;;4281   				{
;;;4282   					/* The notified task has a priority above the currently
;;;4283   					executing task so a yield is required. */
;;;4284   					if( pxHigherPriorityTaskWoken != NULL )
000dfa  2e00              CMP      r6,#0
;;;4285   					{
;;;4286   						*pxHigherPriorityTaskWoken = pdTRUE;
000dfc  bf18              IT       NE
000dfe  f8c69000          STRNE    r9,[r6,#0]
                  |L1.3586|
;;;4287   					}
;;;4288   				}
;;;4289   				else
;;;4290   				{
;;;4291   					mtCOVERAGE_TEST_MARKER();
;;;4292   				}
;;;4293   			}
;;;4294   		}
;;;4295   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000e02  4640              MOV      r0,r8
000e04  f7fffffe          BL       vPortClearInterruptMask
;;;4296   
;;;4297   		return xReturn;
000e08  4638              MOV      r0,r7
;;;4298   	}
000e0a  e8bd87f0          POP      {r4-r10,pc}
                  |L1.3598|
000e0e  1d20              ADDS     r0,r4,#4              ;4270
000e10  f7fffffe          BL       uxListRemove
000e14  6ae0              LDR      r0,[r4,#0x2c]         ;4271
000e16  692a              LDR      r2,[r5,#0x10]         ;4271  ; uxTopReadyPriority
000e18  fa09f100          LSL      r1,r9,r0              ;4271
000e1c  4311              ORRS     r1,r1,r2              ;4271
000e1e  6129              STR      r1,[r5,#0x10]         ;4271  ; uxTopReadyPriority
000e20  492e              LDR      r1,|L1.3804|
000e22  eb000080          ADD      r0,r0,r0,LSL #2       ;4271
000e26  eb010080          ADD      r0,r1,r0,LSL #2       ;4271
000e2a  1d21              ADDS     r1,r4,#4              ;4271
000e2c  e7de              B        |L1.3564|
;;;4299   
                          ENDP

                  vTaskNotifyGiveFromISR PROC
;;;4304   
;;;4305   	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
000e2e  e92d41f0          PUSH     {r4-r8,lr}
;;;4306   	{
000e32  460d              MOV      r5,r1
;;;4307   	TCB_t * pxTCB;
;;;4308   	eNotifyValue eOriginalNotifyState;
;;;4309   	UBaseType_t uxSavedInterruptStatus;
;;;4310   
;;;4311   		configASSERT( xTaskToNotify );
;;;4312   
;;;4313   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4314   		maximum	system call (or maximum API call) interrupt priority.
;;;4315   		Interrupts that are	above the maximum system call priority are keep
;;;4316   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4317   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4318   		is defined in FreeRTOSConfig.h then
;;;4319   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4320   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4321   		been assigned a priority above the configured maximum system call
;;;4322   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4323   		from interrupts	that have been assigned a priority at or (logically)
;;;4324   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4325   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4326   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4327   		provided on the following link:
;;;4328   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4329   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;4330   
;;;4331   		pxTCB = ( TCB_t * ) xTaskToNotify;
000e34  4604              MOV      r4,r0
;;;4332   
;;;4333   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000e36  f7fffffe          BL       ulPortSetInterruptMask
000e3a  4607              MOV      r7,r0
;;;4334   		{
;;;4335   			eOriginalNotifyState = pxTCB->eNotifyState;
000e3c  f8940050          LDRB     r0,[r4,#0x50]
;;;4336   			pxTCB->eNotifyState = eNotified;
000e40  2102              MOVS     r1,#2
000e42  f8841050          STRB     r1,[r4,#0x50]
;;;4337   
;;;4338   			/* 'Giving' is equivalent to incrementing a count in a counting
;;;4339   			semaphore. */
;;;4340   			( pxTCB->ulNotifiedValue )++;
000e46  6ce1              LDR      r1,[r4,#0x4c]
000e48  1c49              ADDS     r1,r1,#1
000e4a  64e1              STR      r1,[r4,#0x4c]
;;;4341   
;;;4342   			/* If the task is in the blocked state specifically to wait for a
;;;4343   			notification then unblock it now. */
;;;4344   			if( eOriginalNotifyState == eWaitingNotification )
000e4c  2801              CMP      r0,#1
000e4e  d114              BNE      |L1.3706|
;;;4345   			{
;;;4346   				/* The task should not have been on an event list. */
;;;4347   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4348   
;;;4349   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000e50  4e21              LDR      r6,|L1.3800|
000e52  6af0              LDR      r0,[r6,#0x2c]  ; uxSchedulerSuspended
000e54  f04f0801          MOV      r8,#1                 ;4308
000e58  2800              CMP      r0,#0
;;;4350   				{
;;;4351   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
;;;4352   					prvAddTaskToReadyList( pxTCB );
;;;4353   				}
;;;4354   				else
;;;4355   				{
;;;4356   					/* The delayed and ready lists cannot be accessed, so hold
;;;4357   					this task pending until the scheduler is resumed. */
;;;4358   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000e5a  bf1c              ITT      NE
000e5c  f1040118          ADDNE    r1,r4,#0x18
000e60  481f              LDRNE    r0,|L1.3808|
000e62  d00f              BEQ      |L1.3716|
                  |L1.3684|
000e64  f7fffffe          BL       vListInsertEnd
;;;4359   				}
;;;4360   
;;;4361   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000e68  6ae0              LDR      r0,[r4,#0x2c]
000e6a  6831              LDR      r1,[r6,#0]  ; pxCurrentTCB
000e6c  6ac9              LDR      r1,[r1,#0x2c]
000e6e  4288              CMP      r0,r1
000e70  d903              BLS      |L1.3706|
;;;4362   				{
;;;4363   					/* The notified task has a priority above the currently
;;;4364   					executing task so a yield is required. */
;;;4365   					if( pxHigherPriorityTaskWoken != NULL )
000e72  2d00              CMP      r5,#0
;;;4366   					{
;;;4367   						*pxHigherPriorityTaskWoken = pdTRUE;
000e74  bf18              IT       NE
000e76  f8c58000          STRNE    r8,[r5,#0]
                  |L1.3706|
;;;4368   					}
;;;4369   				}
;;;4370   				else
;;;4371   				{
;;;4372   					mtCOVERAGE_TEST_MARKER();
;;;4373   				}
;;;4374   			}
;;;4375   		}
;;;4376   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000e7a  4638              MOV      r0,r7
000e7c  e8bd41f0          POP      {r4-r8,lr}
000e80  f7ffbffe          B.W      vPortClearInterruptMask
                  |L1.3716|
000e84  1d20              ADDS     r0,r4,#4              ;4351
000e86  f7fffffe          BL       uxListRemove
000e8a  6ae0              LDR      r0,[r4,#0x2c]         ;4352
000e8c  6932              LDR      r2,[r6,#0x10]         ;4352  ; uxTopReadyPriority
000e8e  fa08f100          LSL      r1,r8,r0              ;4352
000e92  4311              ORRS     r1,r1,r2              ;4352
000e94  6131              STR      r1,[r6,#0x10]         ;4352  ; uxTopReadyPriority
000e96  4911              LDR      r1,|L1.3804|
000e98  eb000080          ADD      r0,r0,r0,LSL #2       ;4352
000e9c  eb010080          ADD      r0,r1,r0,LSL #2       ;4352
000ea0  1d21              ADDS     r1,r4,#4              ;4352
000ea2  e7df              B        |L1.3684|
;;;4377   	}
;;;4378   
                          ENDP

                  prvAddCurrentTaskToDelayedList PROC
;;;3041   
;;;3042   static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
000ea4  b570              PUSH     {r4-r6,lr}
;;;3043   {
;;;3044   	/* The list item will be inserted in wake time order. */
;;;3045   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
000ea6  4c0c              LDR      r4,|L1.3800|
000ea8  4605              MOV      r5,r0                 ;3043
000eaa  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
;;;3046   
;;;3047   	if( xTimeToWake < xTickCount )
000eac  6045              STR      r5,[r0,#4]
000eae  68e0              LDR      r0,[r4,#0xc]  ; xTickCount
000eb0  4285              CMP      r5,r0
;;;3048   	{
;;;3049   		/* Wake time has overflowed.  Place this item in the overflow list. */
;;;3050   		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
;;;3051   	}
;;;3052   	else
;;;3053   	{
;;;3054   		/* The wake time has not overflowed, so the current block list is used. */
;;;3055   		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
000eb2  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000eb4  f1000104          ADD      r1,r0,#4
000eb8  d204              BCS      |L1.3780|
000eba  6b60              LDR      r0,[r4,#0x34]         ;3050  ; pxOverflowDelayedTaskList
000ebc  e8bd4070          POP      {r4-r6,lr}            ;3050
000ec0  f7ffbffe          B.W      vListInsert
                  |L1.3780|
000ec4  6b20              LDR      r0,[r4,#0x30]  ; pxDelayedTaskList
000ec6  f7fffffe          BL       vListInsert
;;;3056   
;;;3057   		/* If the task entering the blocked state was placed at the head of the
;;;3058   		list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;3059   		too. */
;;;3060   		if( xTimeToWake < xNextTaskUnblockTime )
000eca  6aa0              LDR      r0,[r4,#0x28]  ; xNextTaskUnblockTime
000ecc  42a8              CMP      r0,r5
;;;3061   		{
;;;3062   			xNextTaskUnblockTime = xTimeToWake;
000ece  bf88              IT       HI
000ed0  62a5              STRHI    r5,[r4,#0x28]  ; xNextTaskUnblockTime
;;;3063   		}
;;;3064   		else
;;;3065   		{
;;;3066   			mtCOVERAGE_TEST_MARKER();
;;;3067   		}
;;;3068   	}
;;;3069   }
000ed2  bd70              POP      {r4-r6,pc}
;;;3070   /*-----------------------------------------------------------*/
                          ENDP

                  |L1.3796|
                          DCD      ||.bss||+0xb4
                  |L1.3800|
                          DCD      ||.data||
                  |L1.3804|
                          DCD      ||.bss||
                  |L1.3808|
                          DCD      ||.bss||+0x8c

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        100
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  uxTasksDeleted
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0xffffffff
                  uxSchedulerSuspended
                          DCD      0x00000000
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000
